<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-176835131-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-176835131-1');
  </script>

  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marcelo Fernandes" />
  <meta name="dcterms.date" content="2023-04-05" />
  <title>Bit Manipulation In C++</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<style rel="stylesheet">
  html {
    font-size: 16px;
  }
  body {
    hyphens: auto;
    text-align: justify;
    line-height: 1.7;
  }
  a {
    color: #1976d2;
    text-decoration: none;
    border-bottom: 1px solid;
  }
  a:visited {
    color: #1976d2;
  }
  pre.sourceCode {
    border-left: 3px solid #000;
    padding-left: 1.5rem;
    margin: 1em 0;
  }
  figcaption {
    display: none;
  }
</style>
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Bit Manipulation In C++</h1>
<p class="author">Marcelo Fernandes</p>
<p class="date">April 05, 2023</p>
</header>
<h2 id="bit-shifting">Bit shifting</h2>
<p>Bit shifting involves moving bits of a binary number to either the
left or the right. Most programming languages use the characters
<code>&lt;&lt;</code> to indicate a left bit shift, and
<code>&lt;&lt;</code> to indicate a right bit shift.</p>
<p>There are a few common operations that can be performed through.
These are:</p>
<ol type="1">
<li>Multiplication by 2</li>
</ol>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> twenty_three <span class="op">=</span> <span class="bn">0b10111</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> ninety_two <span class="op">=</span> twenty_three <span class="op">&lt;&lt;</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> ninety_two<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li>Division by 2</li>
</ol>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> twenty_two <span class="op">=</span> <span class="bn">0b10110</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> eleven <span class="op">=</span> twenty_two <span class="op">&gt;&gt;</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> eleven<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="3" type="1">
<li>Extracting bits</li>
</ol>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Extract the forth less-significant bit.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> binary_number <span class="op">=</span> <span class="bn">0b01110</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> bit_value <span class="op">=</span> binary_number <span class="op">&gt;&gt;</span> <span class="dv">3</span> <span class="op">&amp;</span> <span class="bn">0b1</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> bit_value<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="4" type="1">
<li>Inserting bits</li>
</ol>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> binary_number <span class="op">=</span> <span class="bn">0b001001</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> one <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// set the 3rd bit to 0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> result <span class="op">=</span> binary_number <span class="op">|</span> <span class="op">(</span>one <span class="op">&lt;&lt;</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> result<span class="op">;</span>  <span class="co">// 0b001101</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="masking">Masking</h2>
<p>A bit masking is a binary number used to enable or disable specific
bits of another binary number. In the examples above we have already
used bit masking.</p>
<p>In our insertion example above, we could have just used a masking
number and the <code>|</code> or bit operator instead:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> binary_number <span class="op">=</span> <span class="bn">0b000001</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> mask <span class="op">=</span> <span class="bn">0b000100</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="op">(</span>binary_number <span class="op">|</span> mask<span class="op">);</span> <span class="co">// 5</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="shifting-and-masking-in-assembly.">Shifting and masking in
assembly.</h2>
<p>Here’s a simple code to set the second bit from right to left using a
mask and the <code>|</code> operator:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> bit_number <span class="op">=</span> <span class="bn">0b00100</span><span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mask <span class="op">=</span> <span class="bn">0b00010</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result <span class="op">=</span> bit_number <span class="op">|</span> mask<span class="op">;</span></span></code></pre></div>
<p>And the assembly code:</p>
<pre class="assembly"><code>bit_number:
        .long   4
mask:
        .long   2
result:
        .zero   4
__static_initialization_and_destruction_0(int, int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        cmp     DWORD PTR [rbp-4], 1
        jne     .L3
        cmp     DWORD PTR [rbp-8], 65535
        jne     .L3
        mov     edx, DWORD PTR bit_number[rip]
        mov     eax, DWORD PTR mask[rip]
        or      eax, edx
        mov     DWORD PTR result[rip], eax
.L3:
        nop
        pop     rbp
        ret
_GLOBAL__sub_I_bit_number:
        push    rbp
        mov     rbp, rsp
        mov     esi, 65535
        mov     edi, 1
        call    __static_initialization_and_destruction_0(int, int)
        pop     rbp
        ret</code></pre>
<p>This assembly code defines a function called
<code>"__static_initialization_and_destruction_0"</code> that takes two
integer arguments and initializes a global variable called “result”
based on their values.</p>
<p>The code starts by reserving space on the stack for the function’s
local variables using the “push” and “mov” instructions. It then stores
the function arguments in the stack at [rbp-4] and [rbp-8].</p>
<p>Next, the code checks if the first argument ([rbp-4]) is equal to 1
using the “cmp” instruction, and jumps to label “.L3” if it is not
equal. It then checks if the second argument ([rbp-8]) is equal to 65535
using the “cmp” instruction, and also jumps to label “.L3” if it is not
equal.</p>
<p>If both conditions are met, the code loads the value of the global
variable <code>"bit_number"</code> into the register edx using the “mov”
instruction with a RIP-relative addressing mode. It then loads the value
of the global variable “mask” into the register eax, and performs a
bitwise OR operation between eax and edx using the “or” instruction. The
resulting value is then stored in the global variable “result” using a
RIP-relative addressing mode.</p>
<p>Finally, the code executes a “nop” instruction, pops the stack to
restore the previous stack pointer using the “pop” instruction, and
returns from the function using the “ret” instruction.</p>
<p>There is also another function called
<code>"_GLOBAL__sub_I_bit_number"</code> that initializes the global
variables “edi” and “esi” with the values 1 and 65535 respectively, and
then calls the <code>"__static_initialization_and_destruction_0"</code>
function with these values. This function is likely called automatically
by the compiler during program startup to initialize the global
variables before main() is called.</p>
<p>This looks a bit more convoluted than you would expect because the
compiler adds the overhead of using <code>1</code> and
<code>65535</code> as “magic numbers” to initialise those variables. I
still don’t know for sure why this needs to happen.</p>
<p>Now let’s try to achieve the same result using shifting to see the
code difference:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> bit_number <span class="op">=</span> <span class="bn">0b00100</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mask <span class="op">=</span> <span class="bn">0b00001</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result <span class="op">=</span> bit_number <span class="op">|</span> <span class="op">(</span>mask <span class="op">&lt;&lt;</span> <span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<p>The assembly code looks like this:</p>
<pre class="assembly"><code>bit_number:
        .long   4
mask:
        .long   1
result:
        .zero   4
__static_initialization_and_destruction_0(int, int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        cmp     DWORD PTR [rbp-4], 1
        jne     .L3
        cmp     DWORD PTR [rbp-8], 65535
        jne     .L3
        mov     eax, DWORD PTR mask[rip]
        lea     edx, [0+rax*8]
        mov     eax, DWORD PTR bit_number[rip]
        or      eax, edx
        mov     DWORD PTR result[rip], eax
.L3:
        nop
        pop     rbp
        ret
_GLOBAL__sub_I_bit_number:
        push    rbp
        mov     rbp, rsp
        mov     esi, 65535
        mov     edi, 1
        call    __static_initialization_and_destruction_0(int, int)
        pop     rbp
        ret</code></pre>
<p>The only difference lies on how the bit shifting happens:
<code>lea edx, [0+rax*8]</code></p>
<p>The instruction <code>lea edx, [0+rax*8]</code> performs a “load
effective address” operation, which computes the memory address that
corresponds to a given memory operand and stores it in the destination
register. In this case, the instruction is calculating an address based
on the value of rax, which was previously loaded with the value of the
mask variable.</p>
<p>The <code>[0+rax*8]</code> memory operand specifies a scaled indexed
addressing mode, where the value of rax is multiplied by the scale
factor of 8 (i.e., each element of the array is 8 bytes wide), and then
added to the base address of 0. Since the base address is 0, the
instruction is effectively multiplying rax by 8.</p>
<p>The reason that the <code>lea edx, [0+rax*8]</code> instruction is
using the lea (load effective address) instruction instead of the mul
(multiply) instruction is that lea is a more efficient way of performing
simple arithmetic operations that involve multiplication by a power of
two.</p>
<p>In this case, the mul instruction would not be appropriate because we
are not multiplying rax by an arbitrary value, but rather by a power of
two (i.e., 8). Since multiplication by a power of two is equivalent to
shifting the binary representation of the number to the left by a
certain number of bits, the lea instruction can be used to accomplish
the same thing as the mul instruction, but more efficiently.</p>
<p>Specifically, the lea instruction can be used to compute an address
that is a scaled version of a register value, where the scale factor can
be 1, 2, 4, or 8. If we needed to multiply by a number greater than 8,
we wouldn’t be using this instruction any more.</p>
</body>
</html>
