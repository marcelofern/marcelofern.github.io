<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
      text-align: justify;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 10px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>February 25th, 2024</p>
<p>Let's begin with a simple example of a misaligned struct</p>
<pre><code class="language-c">// Misaligned struct
struct misaligned {
    char a;        // 1 byte
    int b;         // 4 bytes
    char c;        // 1 byte
};

struct misaligned initialise_misaligned() {
  struct misaligned tmp = {'0', 1, '2'};
  return tmp;
}
</code></pre>
<p>The size of this struct via <code>sizeof(struct misaligned)</code> equals 12.</p>
<p>This is the assembly code generated by gcc with -O3:</p>
<pre><code class="language-asm">initialise_misaligned:
  mov  BYTE PTR -20[rsp], 48
  mov  DWORD PTR -16[rsp], 1
  mov  rax, QWORD PTR -20[rsp]
  mov  BYTE PTR -12[rsp], 50
  mov  edx, DWORD PTR -12[rsp]
  ret
</code></pre>
<ol>
<li>Stores <code>a == '0' == 48</code> 20 bytes below rsp.</li>
<li>Stores <code>b == 1</code> 4 bytes below <code>a</code></li>
<li>Stores <code>c == '2' == 50</code> 4 bytes below <code>b</code>.</li>
</ol>
<p>You can see that there's a lot of alignment and padding going on.
The compiler decided to put <code>b</code> 4 bytes bellow <code>a</code> even though <code>a</code> only needed
a single byte.</p>
<p>This is because, the compiler decided to align the int b; member on a 4-byte
boundary, which resulted in the observed padding between a and b.</p>
<p>On x86 and x86-64 architectures, accessing an int that is not aligned to a
4-byte boundary may require multiple memory accesses, which can be slower than
accessing an aligned int in a single memory access.</p>
<p>The compiler also aligns the entire structure to its most strictly aligned
member. The compiler may also increase the size of structure if necessary, to
make it a multiple of the alignment by adding padding at the end of the
structure. This is known as Tail Padding.</p>
<p>Note that the [rsp-8] will store the instruction pointer when <code>ret</code> is hit.
The struct element <code>c</code> itself starts at [rsp-12] and ends at [rsp-11]. This
means that there are 3 bytes of padding at the end.</p>
<ul>
<li>4 bytes between <code>a</code> and <code>b</code></li>
<li>4 bytes between <code>b</code> and <code>c</code></li>
<li>1 byte for <code>c</code></li>
<li>3 bytes of padding.</li>
</ul>
<p>Total = 12 bytes.</p>
<h2>Better aligning the struct</h2>
<p>MinimiZe memory waste by ordering the structure elements such that
the biggest element comes first, followed by the second biggest, and so
on so forth.</p>
<pre><code class="language-c">struct aligned {
    int b;         // 4 bytes
    char a;        // 1 byte
    char c;        // 1 byte
};

struct aligned initialise_aligned() {
  struct aligned tmp = {'0', 1, '2'};
  return tmp;
}
</code></pre>
<p>The return value for <code>sizeof(struct aligned);</code> is now 8 instead of 12.</p>
<p>The function <code>initialise_aligned</code>, when optimised is simply:</p>
<pre><code class="language-asm">initialise_aligned:
  movabs  rax, 54979876356144
  ret
</code></pre>
<p>Which in binary is:</p>
<pre><code>0b110010 00000001 00000000 00000000 00000000 00110000
</code></pre>
<p>The whole value is aligned now and fits into rax, so the compiler aggressively
optimised it.</p>
<ul>
<li><code>0b110010</code> = 50 == '2' == <code>c</code>.</li>
<li><code>00110000</code> = 48 == '0' == <code>b</code>.</li>
<li><code>00000001</code> =  1 == <code>a</code>.</li>
</ul>
<p>Note that we got 3 bytes of padding between <code>a</code> and <code>b</code> so that <code>a</code> is in a
4 byte boundary.</p>
</body>
</html>
