<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marcelo Fernandes" />
  <title>Intal x64 Assembly Instruction Set</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<style rel="stylesheet">
  html {
    font-size: 16px;
  }
  body {
    hyphens: auto;
    text-align: justify;
    line-height: 1.7;
  }
  a {
    color: #1976d2;
    text-decoration: none;
    border-bottom: 1px solid;
  }
  a:visited {
    color: #1976d2;
  }
  pre.sourceCode {
    border-left: 3px solid #000;
    padding-left: 1.5rem;
    margin: 1em 0;
  }
  figcaption {
    display: none;
  }
</style>
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Intal x64 Assembly Instruction Set</h1>
<p class="author">Marcelo Fernandes</p>
<p class="date">February 18th, 2024</p>
</header>
<h1 id="introduction">Introduction</h1>
<p>This list does not include all of the instructions, only the ones I
have used most frequently.</p>
<h2 id="instructions">Instructions</h2>
<h3 id="adc">ADC</h3>
<p>ADD with Carry Flag.</p>
<p>Adds the destination operand (first operand), the source operand
(second operand), and the carry (CF) flag and stores the result in the
destination operand. The destination operand can be a register or a
memory location; the source operand can be an immediate, a register, or
a memory location. (However, two memory operands cannot be used in one
instruction.) The state of the CF flag represents a carry from a
previous addition. When an immediate value is used as an operand, it is
sign-extended to the length of the destination operand format.</p>
<p>The ADC instruction does not distinguish between signed or unsigned
operands. Instead, the processor evaluates the result for both data
types and sets the OF and CF flags to indicate a carry in the signed or
unsigned result, respectively. The SF flag indicates the sign of the
signed result.</p>
<p>The ADC instruction is usually executed as part of a multibyte or
multiword addition in which an ADD instruction is followed by an ADC
instruction.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">shr</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">3</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">adc</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">0</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="add">ADD</h3>
<p>ADD adds the source operand to the destination operand, and after the
operation, the result replaces the destination operand. The add
operation is an arithmetic add and does not take the Carry flag into
account. (To add using the Carry flag, use the ADC Add with Carry
instruction.) All affected flags are set according to the operation.
Most importantly, if the result does not fit into the destination
operand, the Carry flag is set to 1.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="bn">0x23456</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">mov</span> <span class="kw">rbx</span><span class="op">,</span> <span class="bn">0x54321</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">add</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="and">AND</h3>
<p>Bit-by-bit binary operation. Useful for masking.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">and</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<p>AND performs the AND logical operation on its two operands. Once the
opera- tion is complete, the result replaces the destination operand.
AND is performed on a bit-by-bit basis</p>
<p>Note that the operation makes the Auxiliary carry flag unde- fined.
CF and OF are cleared to 0, and the other affected flags are set
according to the operation’s results.</p>
<h3 id="bt">BT</h3>
<p>Bit test.</p>
<p>It takes two operands, the destination that needs to be tested, and
the source operand, which is the ordinal number bit that you want to
test <strong>starting from 0</strong> (if you want to test the fourth
bit from the right, the source = 3).</p>
<p>BT copies a single specified bit from the left operand to the Carry
flag, where it can be tested or fed back into a quantity using one of
the shift/rotate instruc- tions. Which bit is copied is specified by the
right operand. Neither operand is altered by BT</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">bt</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">4</span> <span class="co">; test bit 4 of rax -&gt; 10000b</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="cf">jnc</span> quit  <span class="co">; we&#39;re done if bit 4 = 0 (not carry).</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |  *  |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="call">CALL</h3>
<p>Calls a routine. Before transferring control, CALL pushes the address
of the instruction immediately after itself onto the stack. This allows
a RET instruction (see also) to pop the return address into RIP and thus
return control to the instruction immediately after the CALL
instruction</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">call</span> MyOtherRoutine</span></code></pre></div>
<p>Note: The procedure <code>MyOtherRoutine</code> must have at least
one RET instruction. Note: Can also be called with a register
address</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">r13</span><span class="op">,</span> myLabel</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">call</span> <span class="kw">r13</span></span></code></pre></div>
<p>Flags affected (none in this case):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="cld">CLD</h3>
<p>Clear Direction Flag. This is relevant for string instruction work.
It defines what direction in memory that a string operation takes.</p>
<p>A clear flag usually means you want to go up-hill on memory. I.e.,
from the lowest address to the highest. If you want the opposite, use
the STD instruction instead.</p>
<h3 id="cmp">CMP</h3>
<p>Compares two values. The destination operand is not affected.</p>
<p>The operation itself is identical to arithmetic subtraction of the
source from the destination without borrow (SUB), save that the result
does not replace the destination.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span> <span class="co">; sets OF, SF, ZF, AF, PF, and CF</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="cf">jne</span> SomeWhere</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="dt">byte</span> <span class="op">[</span>Buffer<span class="op">],</span> <span class="bn">0xFF</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="cf">jng</span> SomeWhereElse</span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="div">DIV</h3>
<p>Warning: contains implicit operand.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">div</span> <span class="kw">rbx</span></span></code></pre></div>
<p>Divides <code>edx:eax</code> by <code>rbx</code>. The result
(quotient) is in EAX and the remainder in EDX. Works similarly for AX,
EAX, RAX.</p>
<p>DIV divides the implicit dividend by the explicit divisor specified
as DIV’s single operand. For dividing by 8-bit quantities, the dividend
is assumed to be in AX. For dividing by 16-bit, 32-bit, and 64-bit
quantities, the dividend is assumed to be in two registers, allowing a
much greater range of calculation. The least significant portion of the
dividend is placed in the “A” register (AX / EAX / RAX), and the most
significant portion of the dividend is placed in the “D” register (DX /
EDX / RDX). Note that even when there is no “high” portion of the
dividend, the “D” register is cleared to 0 by DIV and cannot be used to
hold independent values while a DIV instruction is executed.</p>
<p>DIV leaves no information in the flags. Note, however, that OF, SF,
ZF, AF, PF, and CF become undefined after a DIV instruction.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  ?  |     |     |  ?  |  ?  |  ?  |     |  ?  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="inc-and-dec">INC and DEC</h3>
<p>Increment or decrement the value by one.</p>
<p>INC adds 1 to its single operand and does not affect the Carry flag
CF. Be care- ful about that; it’s a common error to try to use CF after
an INC instruction as though it were ADD instead. INC acting on memory
data forms must be used with a data size specifier such as BYTE, WORD,
DWORD, and QWORD.</p>
<p>DEC subtracts 1 from its single operand and does not affect the Carry
flag CF. Be careful about that; it’s a common error to try to use CF
after a DEC instruction as though it were SUB instead. DEC acting on
memory data forms must be used with a data size specifier such as BYTE,
WORD, DWORD, and QWORD.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |     |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="ja-jae-jna-jnae">JA, JAE, JNA, JNAE</h3>
<p>Note: unsigned comparison. Jump if above (equal/not equal). In this
case, if the value in rax was higher than rbx.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">ja</span> Somewhere</span></code></pre></div>
<h3 id="jb-jbe-jnb-jnbe">JB, JBE, JNB, JNBE</h3>
<p>Note: unsigned comparison. Jump if below (equal/not equal). In this
case, if the value in rax was lower than rbx.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="cf">jb</span> Somewhere</span></code></pre></div>
<h3 id="jc-jnc">JC, JNC</h3>
<p>Jump if the carry flag is set/not set.</p>
<h3 id="je-jne">JE, JNE</h3>
<p>Jump if equal/not equal.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="cf">je</span> Somewhere</span></code></pre></div>
<h3 id="jg-jge-jng-jnge">JG, JGE, JNG, JNGE</h3>
<p>Note: signed comparison. Jump if greater (equal/not equal).</p>
<h3 id="jl-jle-jnl-jnle">JL, JLE, JNL, JNLE</h3>
<p>Note: signed comparison. Jump if less (equal/not equal).</p>
<h3 id="jz-jnz">JZ, JNZ</h3>
<p>Jump if zero (if ZF flag == 0) or not zero.</p>
<pre><code>  mov rax, 2
DoMore:
  dec rax
  jz SomewhereElse
  jmp DoMore</code></pre>
<h3 id="lea">LEA</h3>
<p>Load effective address.</p>
<p>Allows you to calculate the effective address of any element in a
table and drop that address in a register.</p>
<p>LEA derives the address of the source operand and loads that offset
into the destination operand. The destination operand must be a register
and cannot be memory. The source operand must be a memory operand, but
it can be any size.</p>
<p>The address stored in the destination operand is the address of the
first byte of the source in memory, and the size of the source in memory
is unimportant. This is a good, clean way to place the address of a
variable into a register prior to a procedure call or a system call. See
SYSCALL.</p>
<p>LEA can also be used to perform register math, since the address
specified in the second operand is calculated but not accessed. The
address can thus be an address for which your program does not have
permission to access. Any math that can be expressed as a valid address
calculation may be done with LEA.</p>
<p>This is one of the few places where NASM does not require a size
specifier before an operand providing a memory address, again because
LEA calculates the address but moves no data to or from that
address.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">SomeVariable:</span> <span class="dt">dd</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">25</span><span class="op">,</span> <span class="dv">50</span><span class="op">,</span> <span class="dv">75</span><span class="op">,</span> <span class="dv">100</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="bu">lea</span> <span class="kw">rbx</span><span class="op">,</span> <span class="op">[</span>SomeVariable<span class="op">+</span><span class="kw">rcx</span><span class="op">*</span><span class="dv">4</span><span class="op">]</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="bu">lea</span> <span class="kw">rdx</span><span class="op">,</span> <span class="op">[</span><span class="kw">rdx</span><span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="kw">rdx</span><span class="op">]</span> <span class="co">; multiplies rdx by 3</span></span></code></pre></div>
<p>This is often faster than using shifts + adds to multiply a
value.</p>
<h3 id="leave">LEAVE</h3>
<p>Releases the stack frame set up by an earlier ENTER instruction.</p>
<p>It is the equivalent of an epilogue.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">; same as</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rsp</span><span class="op">,</span> <span class="kw">rbp</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="bu">pop</span> <span class="kw">rbp</span></span></code></pre></div>
<h3 id="loop">LOOP</h3>
<p>The LOOP instruction assumes that the RCX register contains the loop
count. When the loop instruction is executed, the RCX register is
decremented and the control jumps to the target label, until the RCX
register value, i.e., the counter reaches the value zero.</p>
<p>LOOP is a combination decrement counter, test, and jump instruction.
It uses CX as the counter in 16-bit modes, ECX in 32-bit modes, or RCX
in 64-bit modes. The operation of LOOP is logistically identical in all
three modes, and I use 64-bit coding as an example here.</p>
<p>LOOP simplifies code by acting as a DEC RCX instruction, a CMP RCX,0
instruction, and JZ instruction in one, executed in that order. A loop
repeat count must be initially loaded into RCX. When the LOOP
instruction is executed, it first decre- ments RCX. Then it tests to see
if RCX = 0. If RCX is not 0, LOOP transfers control to the 8- bit
displacement specified as its operand:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">ECX</span><span class="op">,</span><span class="dv">10</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="fu">l1:</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>&lt;<span class="cf">loop</span> body<span class="op">&gt;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="cf">loop</span> l1</span></code></pre></div>
<blockquote>
<p>Looking at the “8086/8088 User’s Manual: Programmer’s and Hardware
Reference” (Intel 1989) confirms that LOOP is marginally faster than the
combination DEC CX; JNZ. DEC takes 3 clock cycles, JNZ takes 4 (not
taken) or 16 (taken) cycles. So the combination requires 7 or 19 cycles.
LOOP on the other hand requires 5 cycles (not taken) or 17 cycles
(taken), for a saving of 2 cycles.</p>
</blockquote>
<p>Flags affected (none):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<p>Insteresting trick:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="cf">loop</span> <span class="op">$</span></span></code></pre></div>
<p>The above creates an infinite loop until RCX reaches zero. The mark
<code>$</code> corresponds to the current location or address in the
code. This means that <code>loop</code> will loop back to itself.</p>
<h3 id="mov">MOV</h3>
<ul>
<li><code>mov rax, 0x42</code>: rax now stores the value 42h
directly.</li>
<li><code>mov rbx, rax</code>: rbx and rax now both store 42h
directly.</li>
<li><code>mov [rcx], rbx</code>: address stored in rcx now holds
42h.</li>
<li><code>mov rdx, [rbx]</code>: rdx now holds value of address stored
in rbx.</li>
</ul>
<p>Note: If you need to move a signed value use <code>MOVSX</code>
instead.</p>
<p>Flags affected (none):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="movsb-movsw-movsd-movsq">MOVSB, MOVSW, MOVSD, MOVSQ</h3>
<p>The gist of this instruction is this:</p>
<ol type="1">
<li>RSI stores the source of the address in memory.</li>
<li>RDI stores the destination address.</li>
<li>The number of bytes to be moved is placed in the RCX register.</li>
<li>RCX decrements by one after each byte is copied.</li>
</ol>
<p>Don’t forget that RCX counts operations (the number of times a data
item is copied from source to destination) and not bytes!</p>
<p>The DF (direction flag) affects this instruction. It is only
important to set or not set the flag when the memory in RSI and RDI
overlap, otherwise it shouldn’t matter. The Direction flag DF thus
determines whether your copy operation moves up-memory if DF is cleared
(0) and down-memory if DF is set (1).</p>
<p>The MOVSB can operate automatically (via <code>REP</code>) or
semi-automatically, by manually decrementing RCX.</p>
<p>Flags affected (none):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="movsx">MOVSX</h3>
<p>“Move with signed extension” used when moving values that are
negative. Note that this instruction allows operands of different
sizes!</p>
<p>MOVSX operates like MOV but copies values from source operand to the
destina- tion operand with sign extension. That is, it carries the sign
bit of the smaller source operand to the sign bit of the larger
destination operand. This way, for example, a 16-bit signed value in AX
will still be a signed value when copied into 32-bit register EDX or
64-bit register RDX. Without sign extension, the sign bit of AX would
simply become another bit in the binary value copied into RDX, and the
value in RDX would bear no resemblance to the supposedly identical value
in AX.</p>
<pre><code>xor rax, rax
mov ax, -42
movsx rbx,ax</code></pre>
<p>Flags affected (none):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="mul">MUL</h3>
<p>Warning: contains implicit operand.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="bu">mul</span> <span class="kw">rbx</span></span></code></pre></div>
<p>MUL multiplies its single operand by AL, AX, EAX, or RAX, and the
result is placed in AX, in DX:AX, in EDX:EAX, or in RDX:RAX. If MUL is
given an 8-bit operand (either an 8- bit register or an 8-bit memory
operand), the results will be placed in AX. This means that AH will be
affected, even if the results will fit entirely in AL</p>
<p>The above multiplies the value of RBX x RAX. The result would be
stored in two registers, <code>RDX:RAX</code>.</p>
<p>It always multiplies the explicit operand by one of
<code>AX,EAX,RAX</code>. And if it needs to store more than the size of
the register, it uses <code>DX,EDX,RDX</code> to store the high-order
portion.</p>
<p>Not every multiplication will need the high-order register. If not,
the carry flag CF will be set to 0.</p>
<p>Note: It’s easy to assume that IMUL is identical to MUL save for
IMUL’s ability to operate on signed values. Not so: IMUL has more legal
instruction forms and is considerably more complex than MU</p>
<p>The Carry and Overflow flags are cleared to 0 if the result value is
0; other- wise, both are set to 1. Remember that SF, ZF, AF, and PF
become undefined after MUL.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  ?  |  ?  |     |  ?  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="neg">NEG</h3>
<p>Turns the value to its equivalent two’s complement negative. Use this
instead of trying to manually set the negative bit on.</p>
<p>The two’s compliment algorithm is basically:</p>
<ul>
<li>Step 1: starting with the binary representation of the number, with
the leading bit being a sign bit;</li>
<li>Step 2: inverting (or flipping) all bits – changing every 0 to 1,
and every 1 to 0;</li>
<li>Step 3: adding 1 to the entire inverted number, ignoring any
overflow. Accounting for overflow will produce the wrong value for the
result.</li>
</ul>
<div class="sourceCode" id="cb32"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="bn">0x42</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">neg</span> <span class="kw">rax</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">add</span> <span class="kw">rax</span><span class="op">,</span> <span class="bn">0x42</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="or">OR</h3>
<p>Bit-by-bit OR binary operation</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">or</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span></code></pre></div>
<p>Note that the OR instruction makes the Auxiliary Carry flag
undefined. CF and OF are cleared to 0, and the other affected flags are
set according to the operation’s result.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="pop">POP</h3>
<p>Pops an item of data off the stack.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="bu">pop</span> <span class="kw">rax</span> <span class="co">; pops 64bits from the stack</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="bu">pop</span> <span class="op">[</span><span class="kw">ebx</span><span class="op">]</span><span class="co">; pops 32bits from the stack onto the memory pointed by ebx</span></span></code></pre></div>
<p>As with <code>PUSH</code>, it only works with 16bits or 64bits at the
time.</p>
<p>No flags are affected.</p>
<h3 id="popfq">POPFQ</h3>
<p>Pops 64 bits off the stack onto rflags</p>
<h3 id="push">PUSH</h3>
<p>Pushes a 16bit or 64bit register or memory value onto the stack. It
doesn’t work for 8bit or 32bit registers.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="bu">push</span> <span class="kw">rax</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="bu">push</span> <span class="op">[</span><span class="kw">rbx</span><span class="op">]</span></span></code></pre></div>
<p>In Intel x64, where the stack grows downwards, if we push a 64bit
register to the stack, the RSP (register stack pointer) will be
decremented by 64bits and whatever that needs to be stored is saved at
that memory address pointed by RSP. The “empty” 64bits space is now
filled with the value that was pushed.</p>
<p>No flags are affected.</p>
<h3 id="pushfq">PUSHFQ</h3>
<p>Similar to <code>PUSH</code>, but pushes the rflags register. It
takes no operands.</p>
<h3 id="rcr">RCR</h3>
<p>Rotate carry right.</p>
<p>The right rotate instruction shifts all bits in the register or
memory operand specified. The carry flag (CF) is included in the
rotation. The least significant bit is rotated to the carry flag, the
carry flag is rotated to the most significant bit position, all other
bits are shifted to the right. The result includes the original value of
the carry flag.</p>
<p>The first operand value indicates how many times the rotate takes
place. The value is either the contents of the CL register or an
immediate number. For a single rotate, where the first operand is one,
the overflow flag (OF) is defined. For all other cases, OF is undefined.
After the shift, the carry flag bit is XORed with the two most
significant result bits.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="bu">rcr</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">1</span></span></code></pre></div>
<h3 id="rep">REP</h3>
<p>Repeat string-operation until tested-condition</p>
<p>Use the rep (repeat while equal), repnz (repeat while nonzero) or
repz (repeat while zero) prefixes in conjunction with string operations.
Each prefix causes the associated string instruction to repeat until the
count register (CX) or the zero flag (ZF) matches a tested
condition.</p>
<h3 id="rol-ror">ROL / ROR</h3>
<p>ROL: Similar to a shift left instruction, but the left-most bit is
moved down to the right-most bit instead of going to the carry flag.</p>
<p>ROR: Similar to a shift right instruction, but the right-most bit is
moved down to the left-most bit instead of going to the carry flag.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">rol</span> <span class="op">&lt;</span>register<span class="op">/</span>memory<span class="op">&gt;,</span> <span class="op">&lt;</span>count<span class="op">&gt;</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |  *  |     |     |  *  |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="sbb">SBB</h3>
<p>Adds the source operand (second operand) and the carry (CF) flag, and
subtracts the result from the destination operand (first operand). The
result of the subtraction is stored in the destination operand. The
destination operand can be a register or a memory location; the source
operand can be an immediate, a register, or a memory location.</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="bu">not</span> <span class="kw">rdx</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="bu">neg</span> <span class="kw">rax</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="bu">sbb</span> <span class="kw">rdx</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="shl-shr">SHL / SHR</h3>
<p>“Shift left” and “shift right”</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">shl</span> <span class="op">&lt;</span>register<span class="op">/</span>memory<span class="op">&gt;,</span> <span class="op">&lt;</span>count<span class="op">&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">shr</span> <span class="op">&lt;</span>register<span class="op">/</span>memory<span class="op">&gt;,</span> <span class="op">&lt;</span>count<span class="op">&gt;</span></span></code></pre></div>
<p>The number of bit positions shifted may be specified either as an
8-bit immediate value or by the value in CL—not CX/ECX/RCX. (The 8086
and 8088 are limited to the immediate value 1.)</p>
<p>With SHL, the leftmost bit of the operand is shifted into CF; the
rightmost bit is cleared to 0. With SHR, the rightmost bit is shifted
into CF; the leftmost bit is cleared to 0. The Auxiliary Carry flag AF
becomes undefined after both SHL and SHR. OF is modified only by the
shift-by-one forms. After any of the shift-by-CL forms, OF becomes
undefined.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="stosb-stosw-stosd-stosq">STOSB, STOSW, STOSD, STOSQ</h3>
<p>STOre String by Byte.</p>
<ul>
<li>RDI must be loaded with the address of the destination string. Think
R<code>DI</code> for destination index.</li>
<li>AL must be loaded with the 8-bit value to be stored in the
string.</li>
<li>RCX must be loaded with the number of times the value in AL is to be
stored in the string. No matter if you CLD or STD beforehand RCX will
<em>decrement</em>.</li>
<li>The Direction flag (DF) must be set or cleared, depending on whether
you want the search to be up-memory (cleared; use CLD) or down memory
(set; use STD).</li>
</ul>
<p>You must decrement RCX unless you use <code>rep stosb</code>
instead.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cld</span> <span class="co">; clear DF so we&#39;re counting up-memory.</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">al</span><span class="op">,</span> FILLCHR <span class="co">; put the buffer filler char in AL.</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rdi</span><span class="op">,</span>VidBuff <span class="co">; point the destination index at buffer.</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rcx</span><span class="op">,</span> COLS<span class="op">*</span>ROWS <span class="co">; put the count of chars stored into RCX.</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="bu">rep</span> <span class="bu">stosb</span> <span class="co">; blast chars at the buffer.</span></span></code></pre></div>
<p>Does not affect flags.</p>
<h3 id="sub">SUB</h3>
<p>SUB performs a subtraction without borrow, where the source operand
is subtracted from the destination operand, and the result replaces the
destination operand. If the result is negative, the Carry flag CF is
set.</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">AX</span><span class="op">,</span><span class="kw">DX</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">AL</span><span class="op">,</span><span class="kw">DL</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">EBP</span><span class="op">,</span><span class="dv">17</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">RAX</span><span class="op">,</span><span class="dv">0</span><span class="er">FFFBH</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="syscall">SYSCALL</h3>
<p>A way to call Linux syscalls from assembly.</p>
<p>The available syscalls can be found here:
<code>/usr/include/asm/unistd_64.h</code>. To see the register order for
the architecture (e.g x86-64) visit the man page at
<code>man syscall</code></p>
<pre><code>The second table shows the registers used to pass the system call arguments.
Arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes
──────────────────────────────────────────────────────────────
i386          ebx   ecx   edx   esi   edi   ebp   -
x86-64        rdi   rsi   rdx   r10   r8    r9    -
x32           rdi   rsi   rdx   r10   r8    r9    -</code></pre>
<p>Arguments for each POSIX syscall can be found by typing
<code>man 2 exit</code> note the “2” argument to man which will link you
to the system calls documentation.</p>
<p>Note: syscall uses RAX, RCX, and R11 internally, so you can’t assume
that their values will remain the same after the call do
<code>syscall</code></p>
<p>Note 2: whether or not a register (like R9, say) is used to pass a
parameter to a system call, that register i not preserved. Only seven
registers are preserved by Linux across a system call: r12, r13, r14,
r15, rbx, rsp, and rbp.</p>
<p>Useful reference: https://hackeradam.com/x86-64-linux-syscalls/
Useful google term: “system call table x64”</p>
<p>No flags are affected.</p>
<h3 id="test">TEST</h3>
<p>Note: Prefer <code>BT</code> instead!</p>
<p>Useful for mask testing. It does the same job as <code>AND</code>,
but without changing the value of the destination.</p>
<p>If the ZF (zero flag) is set to 0, it means that the mask worked. If
it’s set to 1, the mask didn’t work. It sounds a bit
counter-intuitive.</p>
<p>Caveat: TEST is only useful for finding 1 bit. If you need to find 0
bits, you need to flip each bit with the NOT instruction first.</p>
<p>Caveat 2: TEST only works with a single bit. If you need to check if
more than one bit is set to 1, it won’t work.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> <span class="op">&lt;</span>operand<span class="op">&gt;,</span> <span class="op">&lt;</span>bit mask<span class="op">&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> <span class="kw">rax</span><span class="op">,</span><span class="bn">0x8</span> <span class="co">; checks if bit 3 is up.</span></span></code></pre></div>
<h3 id="xchg">XCHG</h3>
<p>Exchange the value of two variables (swap them)</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="bu">xchg</span> <span class="kw">cl</span><span class="op">,</span><span class="kw">ch</span></span></code></pre></div>
<p>No flags are affected.</p>
<h3 id="xlat">XLAT</h3>
<p>The xlat instruction in x86 assembly language stands for “translate
byte at DS:[(E)BX] and store result in AL.” It is used to perform a
simple byte lookup and load the result into the AL register.</p>
<ul>
<li>The contents of the EBX register (or BX if in 16-bit mode) are
treated as an offset address in the DS (Data Segment) segment.</li>
<li>The byte at the calculated memory address (DS:[(E)BX]) is
fetched.</li>
<li>The fetched byte is then moved into the AL register.</li>
</ul>
<p>This instruction is often used in conjunction with string operations
or table lookups, where EBX holds an offset or index into a data table,
and xlat is used to retrieve a byte from that table.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="bu">section</span> <span class="op">.</span>data</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    str_table <span class="dt">db</span> <span class="st">&#39;0123456789ABCDEF&#39;</span>  <span class="co">; Hexadecimal digits lookup table</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="bu">section</span> <span class="op">.</span>text</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    global _start</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="fu">_start:</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">mov</span> <span class="kw">ebx</span><span class="op">,</span> <span class="dv">10</span><span class="co">; Index 10 in the table corresponds to the hexadecimal digit &#39;A&#39;</span></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">xlat</span>       <span class="co">; AL now contains &#39;A&#39;</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Continue with further instructions...</span></span></code></pre></div>
<p>No flags are affected.</p>
<h3 id="xor">XOR</h3>
<p>This is a nice trick, xor’ing something against itself yields zero.
So if you want to zero a register, it’s faster to do:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="bu">xor</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rax</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">; instead of</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">0</span></span></code></pre></div>
<p>Because we don’t have to go out to memory to load the immediate value
0.</p>
<p>The XOR operation yields a 1 if the operands are different and a 0 if
the operands are the same. Note that the XOR instruction makes the
Auxiliary Carry flag AF undefined. CF and OF are cleared to 0, and the
other affected flags are set according to the operation’s results.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
</body>
</html>
