<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marcelo Fernandes" />
  <meta name="dcterms.date" content="2024-01-13" />
  <title>x64 Assembly Language Step By Step, 4th Edition</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
<style rel="stylesheet">
  html {
    font-size: 16px;
  }
  body {
    hyphens: auto;
    text-align: justify;
    line-height: 1.7;
  }
  a {
    color: #1976d2;
    text-decoration: none;
    border-bottom: 1px solid;
  }
  a:visited {
    color: #1976d2;
  }
  pre.sourceCode {
    border-left: 3px solid #000;
    padding-left: 1.5rem;
    margin: 1em 0;
  }
  figcaption {
    display: none;
  }
</style>
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">x64 Assembly Language Step By Step, 4th Edition</h1>
<p class="author">Marcelo Fernandes</p>
<p class="date">January 13, 2024</p>
</header>
<h2 id="notes-about-gdb">Notes about GDB</h2>
<ol type="1">
<li>Set the layout <code>layout asm</code>.</li>
<li>Use <code>ni</code> and <code>si</code> (next instruction / step
instruction).</li>
<li>use <code>i r rax</code> (info register rax) to inspect a
register.</li>
<li>run <code>set disassembly-flavor intel</code> so MOV instructions
aren’t in reverse.</li>
<li>use <code>x 0x402000</code> to print value starting in memory block
0x402000</li>
<li>use <code>x/xg 0x402000</code> to do the same but print 64bit in hex
decimal.</li>
<li>flag register is available as <code>i r eflags</code></li>
<li>You can normally use <code>p</code> for printing .data (casting them
in C!)</li>
</ol>
<h2 id="registers">Registers</h2>
<h3 id="cheatsheet">Cheatsheet</h3>
<pre><code>| 64 bits | 32 bits | 16 bits | 8 bits |
| rax     |  eax    | ax      | al     |
| rbx     |  ebx    | bx      | bl     |
| rcx     |  ecx    | cx      | cl     |
| rdx     |  edx    | dx      | dl     |
| rsi     |  esi    | si      | sil    |
| rdi     |  edi    | di      | dil    |
| rbp     |  ebp    | bp      | bpl    |
| rsp     |  esp    | sp      | spl    |
| r8      |  r8d    | r8w     | r8b    |
| r9      |  r9d    | r9w     | r9b    |
| r10     |  r10d   | r10w    | r10b   |
| r11     |  r11d   | r11w    | r11b   |
| r12     |  r12d   | r12w    | r12b   |
| r13     |  r13d   | r13w    | r13b   |
| r14     |  r14d   | r14w    | r14b   |
| r15     |  r15d   | r15w    | r15b   |</code></pre>
<h3 id="flags-register-eflags">FLAGS register (eflags)</h3>
<ul>
<li><p><code>Bit: 0, Label: CF, Description</code>: Carry Flag: Set by
arithmetic instructions which generate either a carry or borrow. Set
when an operation generates a carry to or a borrow from a destination
operand.</p></li>
<li><p><code>Bit: 2, Label: PF, Description</code>: Parity flag: Set by
most CPU instructions if the least significant (aka the low-order bits)
of the destination operand contain an even number of 1’s.</p></li>
<li><p><code>Bit: 4, Label: AF, Description</code>: Auxiliary Carry
Flag: Set if there is a carry or borrow involving bit 4 of EAX. Set when
a CPU instruction generates a carry to or a borrow from the low-order 4
bits of an operand. This flag is used for binary coded decimal (BCD)
arithmetic.</p></li>
<li><p><code>Bit: 6, Label: ZF, Description</code>: Zero Flag: Set by
most instructions if the result an operation is binary zero.</p></li>
<li><p><code>Bit: 7, Label: SF, Description</code>: Sign Flag: Most
operations set this bit the same as the most significant bit (aka
high-order bit) of the result. 0 is positive, 1 is negative.</p></li>
<li><p><code>Bit: 8, Label: TF, Description</code>: Trap Flag:
(sometimes named a Trace Flag.) Permits single stepping of programs.
After executing a single instruction, the processor generates an
internal exception 1. When Trap Flag is set by a program, the processor
generates a single-step interrupt after each instruction. A debugging
program can use this feature to execute a program one instruction at a
time.</p></li>
<li><p><code>Bit: 9, Label: IF, Description</code>: Interrupt Enable
Flag: when set, the processor recognizes external interrupts on the INTR
pin. When set, interrupts are recognized and acted on as they are
received. The bit can be cleared to turn off interrupt processing
temporarily.</p></li>
<li><p><code>Bit:10, Label: DF, Description</code>: Direction Flag: Set
and cleared using the STD and CLD instructions. It is used in string
processing. When set to 1, string operations process down from high
addresses to low addresses. If cleared, string operations process up
from low addresses to high addresses.</p></li>
<li><p><code>Bit:11, Label: OF, Description</code>: Overflow Flag: Most
arithmetic instructions set this bit, indicating that the result was too
large to fit in the destination. When set, it indicates that the result
of an operation is too large or too small to fit in the destination
operand.</p></li>
<li><p><code>Bit:12-13, Label: IOPL , Description</code>: Input/Output
privilege level flags: Used in protected mode to generate four levels of
security.</p></li>
<li><p><code>Bit:14, Label: NT, Description</code>: Nested Task Flag:
Used in protected mode. When set, it indicates that one system task has
invoked another via a CALL Instruction, rather than a JMP.</p></li>
<li><p><code>Bit:16, Label: RF, Description</code>: Resume Flag: Used by
the debug registers DR6 and DR7. It enables you to turn off certain
exceptions while debugging code.</p></li>
<li><p><code>Bit:17, Label: VM, Description</code>: Virtual 8086 Mode
flag: Permits 80386 to behave like a high speed 8086.</p></li>
</ul>
<h4 id="relevant-flags">Relevant flags</h4>
<ul>
<li><code>SF</code>: Sign Flag. Set when the result of an operation
forces the operand to become negative.</li>
<li><code>ZF</code>: Zero Flag. Set when the result of an operation
become zero (conditional jumps).</li>
<li><code>OF</code>: Overflow Flag. Set when the result of an arithmetic
operation on a signed integer is too large to fit.</li>
<li><code>CF</code>: Carry Flag. Used in unsigned arithmetic
expressions.</li>
<li><code>IF</code>: Interrupt flag: Usually active when debugging (step
through code).</li>
</ul>
<h2 id="instructions">Instructions</h2>
<h3 id="add">ADD</h3>
<p>ADD adds the source operand to the destination operand, and after the
operation, the result replaces the destination operand. The add
operation is an arithmetic add and does not take the Carry flag into
account. (To add using the Carry flag, use the ADC Add with Carry
instruction.) All affected flags are set according to the operation.
Most importantly, if the result does not fit into the destination
operand, the Carry flag is set to 1.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="bn">0x23456</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">mov</span> <span class="kw">rbx</span><span class="op">,</span> <span class="bn">0x54321</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">add</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="and">AND</h3>
<p>Bit-by-bit binary operation. Useful for masking.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">and</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<p>AND performs the AND logical operation on its two operands. Once the
opera- tion is complete, the result replaces the destination operand.
AND is performed on a bit-by-bit basis</p>
<p>Note that the operation makes the Auxiliary carry flag unde- fined.
CF and OF are cleared to 0, and the other affected flags are set
according to the operation’s results.</p>
<h3 id="bt">BT</h3>
<p>Bit test.</p>
<p>It takes two operands, the destination that needs to be tested, and
the source operand, which is the ordinal number bit that you want to
test <strong>starting from 0</strong> (if you want to test the fourth
bit from the right, the source = 3).</p>
<p>BT copies a single specified bit from the left operand to the Carry
flag, where it can be tested or fed back into a quantity using one of
the shift/rotate instruc- tions. Which bit is copied is specified by the
right operand. Neither operand is altered by BT</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">bt</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">4</span> <span class="co">; test bit 4 of rax -&gt; 10000b</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="cf">jnc</span> quit  <span class="co">; we&#39;re done if bit 4 = 0 (not carry).</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |  *  |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="call">CALL</h3>
<p>Calls a routine. Before transferring control, CALL pushes the address
of the instruction immediately after itself onto the stack. This allows
a RET instruction (see also) to pop the return address into RIP and thus
return control to the instruction immediately after the CALL
instruction</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">call</span> MyOtherRoutine</span></code></pre></div>
<p>Note: The procedure <code>MyOtherRoutine</code> must have at least
one RET instruction. Note: Can also be called with a register
address</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">r13</span><span class="op">,</span> myLabel</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">call</span> <span class="kw">r13</span></span></code></pre></div>
<p>Flags affected (none in this case):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="cld">CLD</h3>
<p>Clear Direction Flag. This is relevant for string instruction work.
It defines what direction in memory that a string operation takes.</p>
<p>A clear flag usually means you want to go up-hill on memory. I.e.,
from the lowest address to the highest. If you want the opposite, use
the STD instruction instead.</p>
<h3 id="cmp">CMP</h3>
<p>Compares two values. The destination operand is not affected.</p>
<p>The operation itself is identical to arithmetic subtraction of the
source from the destination without borrow (SUB), save that the result
does not replace the destination.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span> <span class="co">; sets OF, SF, ZF, AF, PF, and CF</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">jne</span> SomeWhere</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="dt">byte</span> <span class="op">[</span>Buffer<span class="op">],</span> <span class="bn">0xFF</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="cf">jng</span> SomeWhereElse</span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="div">DIV</h3>
<p>Warning: contains implicit operand.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="bu">div</span> <span class="kw">rbx</span></span></code></pre></div>
<p>Divides <code>edx:eax</code> by <code>rbx</code>. The result
(quotient) is in EAX and the remainder in EDX. Works similarly for AX,
EAX, RAX.</p>
<p>DIV divides the implicit dividend by the explicit divisor specified
as DIV’s single operand. For dividing by 8-bit quantities, the dividend
is assumed to be in AX. For dividing by 16-bit, 32-bit, and 64-bit
quantities, the dividend is assumed to be in two registers, allowing a
much greater range of calculation. The least significant portion of the
dividend is placed in the “A” register (AX / EAX / RAX), and the most
significant portion of the dividend is placed in the “D” register (DX /
EDX / RDX). Note that even when there is no “high” portion of the
dividend, the “D” register is cleared to 0 by DIV and cannot be used to
hold independent values while a DIV instruction is executed.</p>
<p>DIV leaves no information in the flags. Note, however, that OF, SF,
ZF, AF, PF, and CF become undefined after a DIV instruction.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  ?  |     |     |  ?  |  ?  |  ?  |     |  ?  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="inc-and-dec">INC and DEC</h3>
<p>Increment or decrement the value by one.</p>
<p>INC adds 1 to its single operand and does not affect the Carry flag
CF. Be care- ful about that; it’s a common error to try to use CF after
an INC instruction as though it were ADD instead. INC acting on memory
data forms must be used with a data size specifier such as BYTE, WORD,
DWORD, and QWORD.</p>
<p>DEC subtracts 1 from its single operand and does not affect the Carry
flag CF. Be careful about that; it’s a common error to try to use CF
after a DEC instruction as though it were SUB instead. DEC acting on
memory data forms must be used with a data size specifier such as BYTE,
WORD, DWORD, and QWORD.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |     |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="ja-jae-jna-jnae">JA, JAE, JNA, JNAE</h3>
<p>Note: unsigned comparison. Jump if above (equal/not equal). In this
case, if the value in rax was higher than rbx.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="cf">ja</span> Somewhere</span></code></pre></div>
<h3 id="jb-jbe-jnb-jnbe">JB, JBE, JNB, JNBE</h3>
<p>Note: unsigned comparison. Jump if below (equal/not equal). In this
case, if the value in rax was lower than rbx.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="cf">jb</span> Somewhere</span></code></pre></div>
<h3 id="jc-jnc">JC, JNC</h3>
<p>Jump if the carry flag is set/not set.</p>
<h3 id="je-jne">JE, JNE</h3>
<p>Jump if equal/not equal.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cmp</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="cf">je</span> Somewhere</span></code></pre></div>
<h3 id="jg-jge-jng-jnge">JG, JGE, JNG, JNGE</h3>
<p>Note: signed comparison. Jump if greater (equal/not equal).</p>
<h3 id="jl-jle-jnl-jnle">JL, JLE, JNL, JNLE</h3>
<p>Note: signed comparison. Jump if less (equal/not equal).</p>
<h3 id="jz-jnz">JZ, JNZ</h3>
<p>Jump if zero (if ZF flag == 0) or not zero.</p>
<pre><code>  mov rax, 2
DoMore:
  dec rax
  jz SomewhereElse
  jmp DoMore</code></pre>
<h3 id="lea">LEA</h3>
<p>Load effective address.</p>
<p>Allows you to calculate the effective address of any element in a
table and drop that address in a register.</p>
<p>LEA derives the address of the source operand and loads that offset
into the destination operand. The destination operand must be a register
and cannot be memory. The source operand must be a memory operand, but
it can be any size.</p>
<p>The address stored in the destination operand is the address of the
first byte of the source in memory, and the size of the source in memory
is unimportant. This is a good, clean way to place the address of a
variable into a register prior to a procedure call or a system call. See
SYSCALL.</p>
<p>LEA can also be used to perform register math, since the address
specified in the second operand is calculated but not accessed. The
address can thus be an address for which your program does not have
permission to access. Any math that can be expressed as a valid address
calculation may be done with LEA.</p>
<p>This is one of the few places where NASM does not require a size
specifier before an operand providing a memory address, again because
LEA calculates the address but moves no data to or from that
address.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">SomeVariable:</span> <span class="dt">dd</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">25</span><span class="op">,</span> <span class="dv">50</span><span class="op">,</span> <span class="dv">75</span><span class="op">,</span> <span class="dv">100</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="bu">lea</span> <span class="kw">rbx</span><span class="op">,</span> <span class="op">[</span>SomeVariable<span class="op">+</span><span class="kw">rcx</span><span class="op">*</span><span class="dv">4</span><span class="op">]</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="bu">lea</span> <span class="kw">rdx</span><span class="op">,</span> <span class="op">[</span><span class="kw">rdx</span><span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="kw">rdx</span><span class="op">]</span> <span class="co">; multiplies rdx by 3</span></span></code></pre></div>
<p>This is often faster than using shifts + adds to multiply a
value.</p>
<h3 id="loop">LOOP</h3>
<p>The LOOP instruction assumes that the RCX register contains the loop
count. When the loop instruction is executed, the RCX register is
decremented and the control jumps to the target label, until the RCX
register value, i.e., the counter reaches the value zero.</p>
<p>LOOP is a combination decrement counter, test, and jump instruction.
It uses CX as the counter in 16-bit modes, ECX in 32-bit modes, or RCX
in 64-bit modes. The operation of LOOP is logistically identical in all
three modes, and I use 64-bit coding as an example here.</p>
<p>LOOP simplifies code by acting as a DEC RCX instruction, a CMP RCX,0
instruction, and JZ instruction in one, executed in that order. A loop
repeat count must be initially loaded into RCX. When the LOOP
instruction is executed, it first decre- ments RCX. Then it tests to see
if RCX = 0. If RCX is not 0, LOOP transfers control to the 8- bit
displacement specified as its operand:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">ECX</span><span class="op">,</span><span class="dv">10</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">l1:</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>&lt;<span class="cf">loop</span> body<span class="op">&gt;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="cf">loop</span> l1</span></code></pre></div>
<blockquote>
<p>Looking at the “8086/8088 User’s Manual: Programmer’s and Hardware
Reference” (Intel 1989) confirms that LOOP is marginally faster than the
combination DEC CX; JNZ. DEC takes 3 clock cycles, JNZ takes 4 (not
taken) or 16 (taken) cycles. So the combination requires 7 or 19 cycles.
LOOP on the other hand requires 5 cycles (not taken) or 17 cycles
(taken), for a saving of 2 cycles.</p>
</blockquote>
<p>Flags affected (none):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="mov">MOV</h3>
<ul>
<li><code>mov rax, 0x42</code>: rax now stores the value 42h
directly.</li>
<li><code>mov rbx, rax</code>: rbx and rax now both store 42h
directly.</li>
<li><code>mov [rcx], rbx</code>: address stored in rcx now holds
42h.</li>
<li><code>mov rdx, [rbx]</code>: rdx now holds value of address stored
in rbx.</li>
</ul>
<p>Note: If you need to move a signed value use <code>MOVSX</code>
instead.</p>
<p>Flags affected (none):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="movsb-movsw-movsd-movsq">MOVSB, MOVSW, MOVSD, MOVSQ</h3>
<p>The gist of this instruction is this:</p>
<ol type="1">
<li>RSI stores the source of the address in memory.</li>
<li>RDI stores the destination address.</li>
<li>The number of bytes to be moved is placed in the RCX register.</li>
<li>RCX decrements by one after each byte is copied.</li>
</ol>
<p>Don’t forget that RCX counts operations (the number of times a data
item is copied from source to destination) and not bytes!</p>
<p>The DF (direction flag) affects this instruction. It is only
important to set or not set the flag when the memory in RSI and RDI
overlap, otherwise it shouldn’t matter. The Direction flag DF thus
determines whether your copy operation moves up-memory if DF is cleared
(0) and down-memory if DF is set (1).</p>
<p>The MOVSB can operate automatically (via <code>REP</code>) or
semi-automatically, by manually decrementing RCX.</p>
<p>Flags affected (none):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="movsx">MOVSX</h3>
<p>“Move with signed extension” used when moving values that are
negative. Note that this instruction allows operands of different
sizes!</p>
<p>MOVSX operates like MOV but copies values from source operand to the
destina- tion operand with sign extension. That is, it carries the sign
bit of the smaller source operand to the sign bit of the larger
destination operand. This way, for example, a 16-bit signed value in AX
will still be a signed value when copied into 32-bit register EDX or
64-bit register RDX. Without sign extension, the sign bit of AX would
simply become another bit in the binary value copied into RDX, and the
value in RDX would bear no resemblance to the supposedly identical value
in AX.</p>
<pre><code>xor rax, rax
mov ax, -42
movsx rbx,ax</code></pre>
<p>Flags affected (none):</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |     |     |     |     |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="mul">MUL</h3>
<p>Warning: contains implicit operand.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="bu">mul</span> <span class="kw">rbx</span></span></code></pre></div>
<p>MUL multiplies its single operand by AL, AX, EAX, or RAX, and the
result is placed in AX, in DX:AX, in EDX:EAX, or in RDX:RAX. If MUL is
given an 8-bit operand (either an 8- bit register or an 8-bit memory
operand), the results will be placed in AX. This means that AH will be
affected, even if the results will fit entirely in AL</p>
<p>The above multiplies the value of RBX x RAX. The result would be
stored in two registers, <code>RDX:RAX</code>.</p>
<p>It always multiplies the explicit operand by one of
<code>AX,EAX,RAX</code>. And if it needs to store more than the size of
the register, it uses <code>DX,EDX,RDX</code> to store the high-order
portion.</p>
<p>Not every multiplication will need the high-order register. If not,
the carry flag CF will be set to 0.</p>
<p>Note: It’s easy to assume that IMUL is identical to MUL save for
IMUL’s ability to operate on signed values. Not so: IMUL has more legal
instruction forms and is considerably more complex than MU</p>
<p>The Carry and Overflow flags are cleared to 0 if the result value is
0; other- wise, both are set to 1. Remember that SF, ZF, AF, and PF
become undefined after MUL.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  ?  |  ?  |     |  ?  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="neg">NEG</h3>
<p>Turns the value to its equivalent two’s complement negative. Use this
instead of trying to manually set the negative bit on.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="bn">0x42</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">neg</span> <span class="kw">rax</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">add</span> <span class="kw">rax</span><span class="op">,</span> <span class="bn">0x42</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="or">OR</h3>
<p>Bit-by-bit OR binary operation</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">or</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span></code></pre></div>
<p>Note that the OR instruction makes the Auxiliary Carry flag
undefined. CF and OF are cleared to 0, and the other affected flags are
set according to the operation’s result.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="pop">POP</h3>
<p>Pops an item of data off the stack.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="bu">pop</span> <span class="kw">rax</span> <span class="co">; pops 64bits from the stack</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="bu">pop</span> <span class="op">[</span><span class="kw">ebx</span><span class="op">]</span><span class="co">; pops 32bits from the stack onto the memory pointed by ebx</span></span></code></pre></div>
<p>As with <code>PUSH</code>, it only works with 16bits or 64bits at the
time.</p>
<p>No flags are affected.</p>
<h3 id="popfq">POPFQ</h3>
<p>Pops 64 bits off the stack onto rflags</p>
<h3 id="push">PUSH</h3>
<p>Pushes a 16bit or 64bit register or memory value onto the stack. It
doesn’t work for 8bit or 32bit registers.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">push</span> <span class="kw">rax</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="bu">push</span> <span class="op">[</span><span class="kw">rbx</span><span class="op">]</span></span></code></pre></div>
<p>In Intel x64, where the stack grows downwards, if we push a 64bit
register to the stack, the RSP (register stack pointer) will be
decremented by 64bits and whatever that needs to be stored is saved at
that memory address pointed by RSP. The “empty” 64bits space is now
filled with the value that was pushed.</p>
<p>No flags are affected.</p>
<h3 id="pushfq">PUSHFQ</h3>
<p>Similar to <code>PUSH</code>, but pushes the rflags register. It
takes no operands.</p>
<h3 id="rep">REP</h3>
<p>Repeat string-operation until tested-condition</p>
<p>Use the rep (repeat while equal), repnz (repeat while nonzero) or
repz (repeat while zero) prefixes in conjunction with string operations.
Each prefix causes the associated string instruction to repeat until the
count register (CX) or the zero flag (ZF) matches a tested
condition.</p>
<h3 id="rol-ror">ROL / ROR</h3>
<p>ROL: Similar to a shift left instruction, but the left-most bit is
moved down to the right-most bit instead of going to the carry flag.</p>
<p>ROR: Similar to a shift right instruction, but the right-most bit is
moved down to the left-most bit instead of going to the carry flag.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">rol</span> <span class="op">&lt;</span>register<span class="op">/</span>memory<span class="op">&gt;,</span> <span class="op">&lt;</span>count<span class="op">&gt;</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|     |  *  |     |     |  *  |     |     |     |     |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="shl-shr">SHL / SHR</h3>
<p>“Shift left” and “shift right”</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>  <span class="bu">shl</span> <span class="op">&lt;</span>register<span class="op">/</span>memory<span class="op">&gt;,</span> <span class="op">&lt;</span>count<span class="op">&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">shr</span> <span class="op">&lt;</span>register<span class="op">/</span>memory<span class="op">&gt;,</span> <span class="op">&lt;</span>count<span class="op">&gt;</span></span></code></pre></div>
<p>The number of bit positions shifted may be specified either as an
8-bit immediate value or by the value in CL—not CX/ECX/RCX. (The 8086
and 8088 are limited to the immediate value 1.)</p>
<p>With SHL, the leftmost bit of the operand is shifted into CF; the
rightmost bit is cleared to 0. With SHR, the rightmost bit is shifted
into CF; the leftmost bit is cleared to 0. The Auxiliary Carry flag AF
becomes undefined after both SHL and SHR. OF is modified only by the
shift-by-one forms. After any of the shift-by-CL forms, OF becomes
undefined.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="stosb-stosw-stosd-stosq">STOSB, STOSW, STOSD, STOSQ</h3>
<p>STOre String by Byte.</p>
<ul>
<li>RDI must be loaded with the address of the destination string. Think
R<code>DI</code> for destination index.</li>
<li>AL must be loaded with the 8-bit value to be stored in the
string.</li>
<li>RCX must be loaded with the number of times the value in AL is to be
stored in the string. No matter if you CLD or STD beforehand RCX will
<em>decrement</em>.</li>
<li>The Direction flag (DF) must be set or cleared, depending on whether
you want the search to be up-memory (cleared; use CLD) or down memory
(set; use STD).</li>
</ul>
<p>You must decrement RCX unless you use <code>rep stosb</code>
instead.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cld</span> <span class="co">; clear DF so we&#39;re counting up-memory.</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">al</span><span class="op">,</span> FILLCHR <span class="co">; put the buffer filler char in AL.</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rdi</span><span class="op">,</span>VidBuff <span class="co">; point the destination index at buffer.</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rcx</span><span class="op">,</span> COLS<span class="op">*</span>ROWS <span class="co">; put the count of chars stored into RCX.</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="bu">rep</span> <span class="bu">stosb</span> <span class="co">; blast chars at the buffer.</span></span></code></pre></div>
<p>Does not affect flags.</p>
<h3 id="sub">SUB</h3>
<p>SUB performs a subtraction without borrow, where the source operand
is subtracted from the destination operand, and the result replaces the
destination operand. If the result is negative, the Carry flag CF is
set.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">AX</span><span class="op">,</span><span class="kw">DX</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">AL</span><span class="op">,</span><span class="kw">DL</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">EBP</span><span class="op">,</span><span class="dv">17</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">RAX</span><span class="op">,</span><span class="dv">0</span><span class="er">FFFBH</span></span></code></pre></div>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  *  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h3 id="syscall">SYSCALL</h3>
<p>A way to call Linux syscalls from assembly.</p>
<p>The available syscalls can be found here:
<code>/usr/include/asm/unistd_64.h</code>. To see the register order for
the architecture (e.g x86-64) visit the man page at
<code>man syscall</code></p>
<pre><code>The second table shows the registers used to pass the system call arguments.
Arch/ABI      arg1  arg2  arg3  arg4  arg5  arg6  arg7  Notes
──────────────────────────────────────────────────────────────
i386          ebx   ecx   edx   esi   edi   ebp   -
x86-64        rdi   rsi   rdx   r10   r8    r9    -
x32           rdi   rsi   rdx   r10   r8    r9    -</code></pre>
<p>Arguments for each POSIX syscall can be found by typing
<code>man 2 exit</code> note the “2” argument to man which will link you
to the system calls documentation.</p>
<p>Note: syscall uses RAX, RCX, and R11 internally, so you can’t assume
that their values will remain the same after the call do
<code>syscall</code></p>
<p>Note 2: whether or not a register (like R9, say) is used to pass a
parameter to a system call, that register i not preserved. Only seven
registers are preserved by Linux across a system call: r12, r13, r14,
r15, rbx, rsp, and rbp.</p>
<p>Useful reference: https://hackeradam.com/x86-64-linux-syscalls/
Useful google term: “system call table x64”</p>
<p>No flags are affected.</p>
<h3 id="test">TEST</h3>
<p>Note: Prefer <code>BT</code> instead!</p>
<p>Useful for mask testing. It does the same job as <code>AND</code>,
but without changing the value of the destination.</p>
<p>If the ZF (zero flag) is set to 0, it means that the mask worked. If
it’s set to 1, the mask didn’t work. It sounds a bit
counter-intuitive.</p>
<p>Caveat: TEST is only useful for finding 1 bit. If you need to find 0
bits, you need to flip each bit with the NOT instruction first.</p>
<p>Caveat 2: TEST only works with a single bit. If you need to check if
more than one bit is set to 1, it won’t work.</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> <span class="op">&lt;</span>operand<span class="op">&gt;,</span> <span class="op">&lt;</span>bit mask<span class="op">&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="bu">test</span> <span class="kw">rax</span><span class="op">,</span><span class="bn">0x8</span> <span class="co">; checks if bit 3 is up.</span></span></code></pre></div>
<h3 id="xchg">XCHG</h3>
<p>Exchange the value of two variables (swap them)</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="bu">xchg</span> <span class="kw">cl</span><span class="op">,</span><span class="kw">ch</span></span></code></pre></div>
<p>No flags are affected.</p>
<h3 id="xlat">XLAT</h3>
<p>The xlat instruction in x86 assembly language stands for “translate
byte at DS:[(E)BX] and store result in AL.” It is used to perform a
simple byte lookup and load the result into the AL register.</p>
<ul>
<li>The contents of the EBX register (or BX if in 16-bit mode) are
treated as an offset address in the DS (Data Segment) segment.</li>
<li>The byte at the calculated memory address (DS:[(E)BX]) is
fetched.</li>
<li>The fetched byte is then moved into the AL register.</li>
</ul>
<p>This instruction is often used in conjunction with string operations
or table lookups, where EBX holds an offset or index into a data table,
and xlat is used to retrieve a byte from that table.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="bu">section</span> <span class="op">.</span>data</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    str_table <span class="dt">db</span> <span class="st">&#39;0123456789ABCDEF&#39;</span>  <span class="co">; Hexadecimal digits lookup table</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="bu">section</span> <span class="op">.</span>text</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    global _start</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="fu">_start:</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">mov</span> <span class="kw">ebx</span><span class="op">,</span> <span class="dv">10</span><span class="co">; Index 10 in the table corresponds to the hexadecimal digit &#39;A&#39;</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">xlat</span>       <span class="co">; AL now contains &#39;A&#39;</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Continue with further instructions...</span></span></code></pre></div>
<p>No flags are affected.</p>
<h3 id="xor">XOR</h3>
<p>This is a nice trick, xor’ing something against itself yields zero.
So if you want to zero a register, it’s faster to do:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="bu">xor</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rax</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">; instead of</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">0</span></span></code></pre></div>
<p>Because we don’t have to go out to memory to load the immediate value
0.</p>
<p>The XOR operation yields a 1 if the operands are different and a 0 if
the operands are the same. Note that the XOR instruction makes the
Auxiliary Carry flag AF undefined. CF and OF are cleared to 0, and the
other affected flags are set according to the operation’s results.</p>
<p>Flags affected:</p>
<pre><code>| AF  | CF  | DF  | IF  | OF  | PF  | SF  | TF  | ZF  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|
|  ?  |  *  |     |     |  *  |  *  |  *  |     |  *  |

AF: Aux carry flag
CF: Carry flag
DF: Direction flag
IF: Interrupt flag
OF: Overflow flag
PF: Parity flag
SF: Sign flag
TF: Trap flag
ZF: Zero flag</code></pre>
<h2 id="sections">Sections</h2>
<h3 id="data">.data</h3>
<p>Contains data definitions of initialised data items. Those have a
value before the program begins:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="bu">SECTION</span> <span class="op">.</span>data</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    MyByte <span class="dt">db</span> <span class="bn">0x7</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    MyWord <span class="dt">dw</span> <span class="bn">0xFFFF</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    MyDoubleWord <span class="dt">dd</span> <span class="bn">0x12345678</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    MyQuadWord <span class="dt">dq</span> <span class="bn">0xFFFFFFFFFFFFFFFF</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    QuadWordArray <span class="dt">dq</span> <span class="st">&quot;21,15,16,7,888,851&quot;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Strings are interesting as their value points to the first byte</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">; in memory where the string lives. Also, strings can be concatenated by</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">; using a comma &quot;,&quot;. Thus, the number 10 is being concatenated to the</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">; string below. 10 == EOL (or new line) in Linux (a.k.a 0xA).</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">EatMsg:</span> <span class="dt">db</span> <span class="st">&quot;Eat at Joe&#39;s!&quot;</span><span class="op">,</span> <span class="dv">10</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">; equ = equate. Use to associate a value with a label. Every time the</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">; assembler finds this label, it swaps by the result of the equation.</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Similar to C&#39;s macros. When NASM reaches the label EatLen, the value of</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">; $ is the location immediately after the last character of EatMsg. We</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">; take this value and &quot;-&quot; subtract it from the location at the beginning of</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">; the EatMsg string. End - Beginning = Length</span></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">EatLen:</span> <span class="pp">equ</span> <span class="op">$-</span>EatMsg</span></code></pre></div>
<p>Data items defined in this section increase the size of the
executable file.</p>
<h3 id="bss-block-start-symbol">.bss (Block Start Symbol)</h3>
<p>In this section you allocate blocks of memory to be used later during
execution.</p>
<p>Data items defined in this section <strong>do not</strong> increase
the size of the executable file. This is because of the way Linux brings
the program into memory, by allocating space in memory for data items in
the <code>.bss</code> section when fetching the executable from
disk.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co">; somewhere in the code</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="bu">lea</span> <span class="kw">rcx</span><span class="op">,</span> <span class="op">[</span>some_memory<span class="op">]</span> <span class="co">; Load effective address of memory location</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co">; then</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="bu">section</span> <span class="op">.</span>bss</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    some_memory resq <span class="dv">1</span> <span class="co">; Reserve 1 quadword (64 bits)</span></span></code></pre></div>
<h4 id="resb-restw-restd-resq">resb / restw / restd/ resq</h4>
<p>Reserve bytes instruction, where N is the number of bytes to
reserve:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="bu">section</span> <span class="op">.</span>bss</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    Buff resb <span class="dv">42</span> <span class="co">; reserves 42 bytes for Buff</span></span></code></pre></div>
<h4 id="equ">equ</h4>
<p>Stands for equate.</p>
<p>Use to associate a value with a label. Every time the assembler finds
this label, it swaps by the result of the equation. Similar to C’s
macros.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>sections <span class="op">.</span>bss</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    BUFFLEN equ <span class="dv">128</span></span></code></pre></div>
<h3 id="text">.text</h3>
<p>This section stores the machine instructions that make up the
program.</p>
<p>All global labels need to be declared in this section, otherwise they
cannot be seen outside of the program.</p>
<h2 id="labels">Labels</h2>
<p>Labels can be global or local:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">; global label</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="fu">MyLabel:</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co">; local label</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="fu">.MyLocalLabel:</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="co">; You can globally jump to a local variable like this (not often needed)</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="cf">jmp</span> MyLabel<span class="op">.</span>MyLocalLabel</span></code></pre></div>
<p>Notes: - The local label will be local to the global label that
precedes it. - A local label cannot be “seen” by any other global label
except the preceding one. This is relevant when a global procedure has
another global procedure inside of it. A local label declared after
those procedures can only be seen by the latest global procedure. - It
can be useful to define global labels that are never referenced, simply
to provide ownership of local labels.</p>
<h2 id="x64-memory-addressing">x64 Memory Addressing</h2>
<pre><code>[ BASE + (INDEX x SCALE) + DISP ]</code></pre>
<ul>
<li>BASE: any general purpose register. Only 32-bit or 64-bit.</li>
<li>INDEX: any general purpose register. Only 32-bit or 64-bit.</li>
<li>SCALE: must be one of the values: 1, 2, 4, or 8.</li>
<li>DISP: displacement may be any 32-bit constant (legacy reasons).</li>
</ul>
<p>Note 1: 32bit and 64bit register can’t be mingled together. Note 2:
All of the elements are optional. Almost any permutation works. Note 3:
The DISP value is usually some variable defined in <code>.data</code> or
<code>.bss</code>.</p>
<pre><code>| Scheme                        | Example             | Description                      |
|-------------------------------|---------------------|----------------------------------|
| [BASE]                        | [rdx]               | Base only                        |
| [DISP]                        | [0F3h]              | Either literal or named constant |
| [BASE + DISP]                 | [rcx + 033x]        | Base plus displacement           |
| [INDEX x SCALE]               | [rax * 4]           | Index times scale                |
| [BASE + INDEX]                | [rax + rbx]         | Base plus index                  |
| [BASE + INDEX x SCALE]        | [rsp + rdi * 2]     | Base plus index times scale      |
| [BASE + INDEX x SCALE + DISP] | [rdx + rax*2 + 20]  | ...                              |</code></pre>
<h2 id="directives">Directives</h2>
<h3 id="extern">EXTERN</h3>
<p>Used to inform that a particular procedure has been declared outside
of the module. Potentially, by another module.</p>
<p>Useful at the top of their section, given that any external
procedures must be declared with <code>EXTERN</code> before being
used.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="bu">SECTION</span> <span class="op">.</span>text</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>EXTERN MyProc<span class="op">,</span> AnotherProc</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="co">; ...</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="bu">SECTION</span> <span class="op">.</span>data</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>EXTERN DotDataVar<span class="op">,</span> anotherDotDataVar</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="co">; ...</span></span></code></pre></div>
<h3 id="global">GLOBAL</h3>
<p>Used to inform that a particular procedure can be used by other
modules. Items declared with GLOBAL <strong>must</strong> be declared
before they are defined.</p>
<p>Practically, this means declaring them at the top of the
<code>.text</code> section or the <code>.data</code> section, whichever
the item belongs to.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>GLOBAL MyProc</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>GLOBAL MyDotDataVar</span></code></pre></div>
<h3 id="include">%INCLUDE</h3>
<p>Allows you to include a file into another file during assembly
operations. Only source code text files can be used. No binaries of any
kind are accepted.</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>%<span class="bu">INCLUDE</span> <span class="st">&quot;textlibgcc.asm</span></span></code></pre></div>
<p>Differently than C, the included file is not inserted into the main
file.</p>
<p>When NASM encouters an <code>%INCLUDE</code>, it stops assembling the
main file and begins assembling the included file.</p>
<p>Once this is done, NASM picks up right where it left in the main
file.</p>
<h3 id="macro-and-endmacro">%MACRO and %ENDMACRO</h3>
<p>Similar to how C macros work. During assembler, they are
“copy-pasted” onto the code before it is compiled. Every macro must have
a parameter count, even if it is 0 like below.</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>%<span class="pp">macro</span> MyMacro <span class="dv">0</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rbx</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">syscall</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>%endmacro</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="co">; later... just place the name of the macro in your code.</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>MyMacro</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="co">; this macro can be in another file:</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>%<span class="bu">include</span> <span class="st">&quot;mymacro.mac&quot;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>MyMacro</span></code></pre></div>
<p>Macros can also have parameters (like in C). In this case, you need
to note on the macro definition, how many parameters it takes.</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>%<span class="pp">macro</span> WriteCtr <span class="dv">3</span> <span class="co">; %1 = row; %2 = string address; %3 = string length.</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">push</span> <span class="kw">rbx</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">push</span> <span class="kw">rdx</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">mov</span> <span class="kw">rdx</span><span class="op">,</span> <span class="op">%</span><span class="dv">3</span> <span class="co">; &lt;--- that&#39;s how you use the input.</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">xor</span> <span class="kw">rbx</span><span class="op">,</span><span class="kw">rbx</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">; etc...</span></span></code></pre></div>
<p>Macro arguments can be literal constants, registers, .text and .bss
variables, etc. They can also have local lables, though they are defined
differently:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>%<span class="pp">macro</span> MacroWithInternalLabel <span class="dv">0</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">; do stuff</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="fu">%%MyInternalLabel:</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">; do stuff</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">jb</span> <span class="op">%%</span>MyInternalLabel</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>%endmacro</span></code></pre></div>
<p>NASM will give a unique name for each time the macro is expanded into
the soruce code. It prefixes the macro label with <code>..@</code> plus
4 digits, like: <code>..@0001.MyInternallabel</code></p>
<h2 id="linux-specifics">Linux Specifics</h2>
<h3 id="command-line-arguments">Command line arguments</h3>
<h4 id="stack-generic-linux-way">Stack (generic Linux-way)</h4>
<p>At start-up:</p>
<ul>
<li>RSP (top of the stack) has a 64-bit number, giving the count of
command-line arguments present on the stack. This value is always
greater or equal to one.</li>
<li>The next 64-bit item up-memory from RSP is the address of the
invocation text that runs the executable. (./my-program)</li>
<li>Remaining command-line arguments, if provided, have their 64-bit
addresses stored up-memory from RSP, with the address of the first
(leftmost) argument followed by the second, and so on.</li>
<li>The list of command-line addresses is terminated by a null pointer,
which is jargon for 64 bits of binary 0.</li>
</ul>
<p>The stack at start time looks like this:</p>
<pre><code>|                     THE STACK                      |
|----------------------------------------------------|
| **64-bit null point (8 bytes of binary 0)**        |
|----------------------------------------------------|
| Full pathname of executable                        |
|----------------------------------------------------|
| Actual env variables (null-terminated strings)     |
|----------------------------------------------------|
| Actual command-line args (null-terminated strings) |
|----------------------------------------------------|
| Actual executable invocation text                  |
|----------------------------------------------------|
| `(System oddments and empty space)`                |
|----------------------------------------------------|
| **64-bit null pointer (8 bytes of binary 0)**      |
|----------------------------------------------------|
| Address of last environment variable               |
|----------------------------------------------------|
| ...(more environment variables)...                 |
|----------------------------------------------------|
| Address of environment variable 3                  |
|----------------------------------------------------|
| Address of environment variable 2                  |
|----------------------------------------------------|
| Address of environment variable 1                  |
|----------------------------------------------------|
| **64-bit null pointer (8 bytes of binary 0)**      |
|----------------------------------------------------|
| Address of last argument                           |
|----------------------------------------------------|
| Address of argument 2                              |
|----------------------------------------------------|
| Address of argument 1                              |
|----------------------------------------------------|
| Address of executable invocation text              |
|----------------------------------------------------|
| Count of arguments (always at least 1)             | &lt;---- RSP: Top of stack
|----------------------------------------------------|</code></pre>
<h4 id="gcc-specific">GCC-specific</h4>
<p>Upon program initiation, the register <code>RDI</code> contains a
value greater or equal to one.</p>
<p>The value indicates how many command-line arguments have been passed
to the executable command.</p>
<p>The register <code>RSI</code> contains the address of a table of
addresses, starting at the first item in the list of command-line
arguments. In Linux, it will always be the name of the program
itself.</p>
<p>Each element in the table of addresses, points to another address.
This address needs to be read, and the string inside of it will be
terminated by a binary 0.</p>
<p>The value of this string can be obtained via the instructions
<code>SCASB</code> (Scan String by Byte).</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rcx</span><span class="op">,</span> <span class="dv">0000</span><span class="er">FFFFh</span> <span class="co">; Limit search to 65535 bytes max.</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cld</span> <span class="co">; search direction is set to up-memory.</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="bu">repne</span> <span class="bu">scasb</span> <span class="co">; search ofr null (0) in string at RDI.</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="cf">jnz</span> Error <span class="co">; Jump to error if null not found.</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co">; later</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="dt">byte</span> <span class="op">[</span><span class="kw">rdi</span><span class="op">-</span><span class="dv">1</span><span class="op">],</span> <span class="dv">10</span> <span class="co">; Store an EOL where the 0 used to be.</span></span></code></pre></div>
<h2 id="c-calling-convention-64bit">C calling convention (64bit)</h2>
<h3 id="entrypoint">Entrypoint</h3>
<p>Instead of <code>_start</code>, glibc will require the entrypoint to
be called <code>main</code>.</p>
<h3 id="function-arguments">Function Arguments</h3>
<p>Passing the first six parameters is done via registers. Any remaining
parameters must be passed on the stack.</p>
<p>The order of arguments is as follows, it differs from the
<code>syscall</code> convention.</p>
<ol type="1">
<li>RDI</li>
<li>RSI</li>
<li>RDX</li>
<li>RCX</li>
<li>R8</li>
<li>R9</li>
</ol>
<h3 id="register-clobber">Register Clobber</h3>
<p>Which registers can a function use internally and thus change? The
following registers <strong>cannot be clobbered</strong>. They are also
called <strong>nonvolatile</strong>:</p>
<h4 id="non-volatile-registers">Non-volatile registers</h4>
<ol type="1">
<li>RSP</li>
<li>RBP</li>
<li>RBX</li>
<li>R12</li>
<li>R13</li>
<li>R14</li>
<li>R15</li>
</ol>
<h4 id="volatile-registers">Volatile registers</h4>
<ol type="1">
<li>RAX</li>
<li>RCX</li>
<li>RDX</li>
<li>RSI</li>
<li>RDI</li>
<li>R8</li>
<li>R9</li>
<li>R10</li>
<li>R11</li>
</ol>
<h3 id="stack-frame">Stack Frame</h3>
<p>A stack frame is a location on the stack marked as belonging to a
particular function.</p>
<p>Compilers depend on stack frames to create local variables in
functions.</p>
<p>It can be thought as the region between the addresses contained in
two registers: The base pointer RBP and stack pointer RSP.</p>
<p>A stack frame is created by pushing a copy of RBP on the stack, and
then coping the stack pointer RSP into register RBP.</p>
<p>This is why the two first instructions in an assembly program that
honours the C calling convention must be:</p>
<h4 id="prolog">Prolog</h4>
<div class="sourceCode" id="cb63"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co">; usually called the program&#39;s prolog. Unless it&#39;s present,</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="co">; gdb will not operate correctly.</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="bu">push</span> <span class="kw">rbp</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rbp</span><span class="op">,</span> <span class="kw">rsp</span></span></code></pre></div>
<h4 id="a-view-of-the-stack">A view of the stack</h4>
<pre><code>| The Stack | content                                  |
|-----------|------------------------------------------|
| RBP+32    | up-memory                                |
| RBP+24    | up-memory                                |
| RBP+16    | up-memory                                |
| RBP+8     | up-memory                                |
|  ...      |  ...                                     |
| RBP+0     | stays here until stack frame destruction |
| RBP-8     | other callee-saved registers             |
| RBP-16    | other callee-saved registers             |
|  ...      |  ...                                     |
| RBP-24    | temporary storage for function           |
| RBP-32    | temporary storage for function           |
| RBP-40    | temporary storage for function           |
|  ...      |  ...                                     |
| RBP-72    | temporary storage RSP points here        |</code></pre>
<h4 id="epilog">Epilog</h4>
<p>Used to undo the logic for creating the stack frame.</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="bu">pop</span> <span class="kw">rbp</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="cf">ret</span></span></code></pre></div>
<h4 id="stack-alignment">Stack Alignment</h4>
<p>Why are prologs and epilogs important?</p>
<p>A new requirement in x64 is that the stack must be aligned on a 16
byte boundary.</p>
<p>What this means is that when you return from a function (like
<code>main:</code>), the stack pointer must be pointing at an address
evenly divisible by 16.</p>
<blockquote>
<p><em>TIP</em>: Aligned to 16 bytes means that the stack pointer is
dividable by 16. If you read it in hexadecimal, it means that the last
digit is a zero.</p>
</blockquote>
<p>Why is this an issue?</p>
<p>When a procedure is called, the caller pushes the return address onto
the stack. A return address is 8 bytes in size (64 bits). But if you
access the stack after adding 8 bytes to it (rather than 16 bytes), bad
things may happen. Keeping the stack aligned on 16-byte boundaries at
all times makes code simpler for a number of things, including the use
of SSE vectors when they are stored on the stack.</p>
<p>When the prolog pushes RBP onto the stack, we now have the return
address with 8 bytes, and the content of RBP, 8 bytes totalling 16
bytes.</p>
<p>The symmetry is repeated when returning from the function, as RBP is
popped (8 bytes), and the return instruction also pops the return
address back to the stack pointer (8 bytes).</p>
<p><code>glibc</code> would have already aligned the stack for you when
<code>main</code> took control.</p>
<p>Ideally, your own procedures should start with the prolog and end
with the epilog. If your procedures are simple and don’t do much to the
stack, you can get away with not using pro/epilog.</p>
<h5 id="addendum-to-not-glibc-programs">Addendum to not-glibc
programs</h5>
<p>If you are not using <code>glibc</code>, you still have to align the
stack:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="bu">push</span> <span class="kw">rbp</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rbp</span><span class="op">,</span> <span class="kw">rsp</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="co">; and the last 4 bits (zeroes)</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="bu">and</span> <span class="kw">rsp</span><span class="op">,</span> <span class="op">-</span><span class="dv">16</span></span></code></pre></div>
<p>The epilog becomes then:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="bu">mov</span> <span class="kw">rsp</span><span class="op">,</span> <span class="kw">rbp</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="bu">pop</span> <span class="kw">rbp</span></span></code></pre></div>
<p>Another difference when not using <code>glibc</code> is that when
returning to Linux, you can’t use the <code>ret</code> instruction. You
must use the Exit service (60) via SYSCALL.</p>
</body>
</html>
