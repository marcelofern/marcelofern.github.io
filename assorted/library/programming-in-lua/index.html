<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 10px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>July 10, 2022</p>
<p>I've decided to start reading this book to get more insight into how to incorporate Lua into Neovim</p>
<h2>Contents</h0>
<ul><li><ol><li><a href="#chapter-1">Chapter Getting started</a> - <a href="#chapter-4">Chapter 4. Strings</a> - <a href="#chapter-5">Chapter 5. Tables</a> - <a href="#chapter-6">Chapter 6. Functions</a> - <a href="#chapter-18">Chapter 18. Generic for</a> - <a href="#chapter-20">Chapter 20. Metatables and Metamethods</a> - <a href="#chapter-21">Chapter 21. Object-Oriented Programming</a></li></ol>
<h2>C Chhaapptteerr  11</h0>
<h3>GGeettttiinngg  SSttaarrtteedd</h0>
<pre><code class="language-lua">
-- file test.lua
print("Hello World")

-- defines a factorial function
function factorial(n)
  if n == 0 then
    return 1
  else
    return n * factorial(n-1)
  end
end

print("enter a number:")
a = io.read("*n")
print(factorial(a))

-- types
type(nil) --> nil
type(true) --> boolean
</code></pre></li></ul>
<p>You can run the code above by passing the <code>test.lua</code> file to the Lua interpreter of your choice.</p>
<pre><code class="language-bash">
luajit test.lua

# If you want to open an iterative session after running the code, use the
# -i flag. This is usually helpful for debugging.
luajit -i test.lua
</code></pre><p>List of reserved words:</p>
<ul><li>and</li><li>break</li><li>do</li><li>else</li><li>elseif</li><li>end</li><li>false</li><li>for</li><li>function</li><li>goto</li><li>if</li><li>in</li><li>local</li><li>nil</li><li>not</li><li>or</li><li>repeat</li><li>return</li><li>then</li><li>true</li><li>until</li><li>while</li></ul>
<p>List of basic types: - nil - boolean - number - string - userdata (type(io.stdin)) - function - table - thread</p>
<pre><code class="language-lua">
type(a) --> nil. It does not return an error.
a = 10
type(a) --> number
a = "string"
type(a) --> string
</code></pre><h3>Exercises</h0>
<p>Run the factorial example. What happens to your program if you enter a negative number? Modify the example to avoid this problem.</p>
<p>A: The program raises a <code>stack overlow</code> error.</p>
<p><code>factorial.lua</code> <pre><code class="language-lua">
#!/usr/bin/luajit</p>

function factorial(n)
  if n < 0 then
    return nil
  elseif n == 0 then
    return 1
  else
    return n * factorial(n-1)
  end
end

print("enter a number:")
a = io.read("*n")
print(factorial(a))
</code></pre><p>Write a simple script that prints its own name without knowing it in advance.</p>
<pre><code class="language-lua">
#!/usr/bin/luajit

function print_file_name()
  print(arg[0])
end

print_file_name()
</code></pre><h2>Chapter 4</h0>
<h3>Strings</h0>
<pre><code class="language-lua">
-- The length operator is `#`
a = "hello"
print(#a) --> 5
print(#"test") --> 4

-- the lib string also has a length function
print(string.len("morning!")) --> 8

-- String concatenation happens with `..`
print("hello " .. "world")

-- long strings use [[ and ]]
body = [[
<body>
  <a href="https://marcelofern.com">Marcelo Fern</a>
</body>
]]
</code></pre><pre><code class="language-lua">
-- or [[= (followed by any number of = signs)
-- and =]]. This is useful when you need to
-- stringfy text that includes ]]
text = [[===
This text has ]]
===]]
</code></pre><pre><code class="language-lua">
-- coercions
print(10 .. 20) --> 1020

-- string to number
tonumber("   -3 ") --> -3
tonumber(" i2 ") --> nil

-- number to string
tostring(3) --> "3"

-- formatting a string
string.format("x = %d y = %d", 10, 20) --> x= 10 y = 20

-- search in string
x, y = string.find("hello world", "wor") --> 7 9
string.find("hello world", "war") --> nil
</code></pre><h2>Chapter 5</h0>
<h3>Tables</h0>
<p>Tables are the only data structuring mechanism in Lua.</p>
<pre><code class="language-lua">
#!/usr/bin/luajit

a = {}
a["x"] = 10
print(a["x"]) --> 10

b = {}
b.x = 20
print(b.x) --> 20
</code></pre><p>Implementing lists / arrays:</p>
<pre><code class="language-lua">
numbers = {10, 20, 30, 40, 50}
print(numbers[1]) --> 10 Indexes in Lua start at 1.
print(#numbers) --> 5 The # calculates the length.

-- note that # is unreliable for lists with holes.

-- iterate over an array
for i=1, #numbers do
  print(numbers[i])
end

-- or use ipairs
for k, v in ipairs(numbers) do
  print(k, v)
end
--> 1 10
--> 2 20
--> 3 30
--> 4 40
--> 5 50

-- append an element at the end of an array
numbers[#numbers + 1] = 60
print(numbers[6]) --> 60
-- or use table.insert
table.insert(numbers, 70)
print(numbers[7]) --> 70

-- remove the last element of an array, returning it as a result
print(table.remove(numbers)) --> 70
print(numbers[#numbers]) --> 60
-- you can also call `table.remove` with
-- the number of the index you want to remove.
-- in that case, the holes will be filled up
-- i.e., each element after the removed one
-- will be brought one position down.
</code></pre><p>Implementing a dictionary</p>
<pre><code class="language-lua">
name = {first="Marcelo", last="Fernandes"}
print(name.first .. " " .. name.last) --> Marcelo Fernandes

-- traverse all key-value pairs
for k, v in pairs(name) do
  print(k, v)
end
--> first Marcelo
--> last Fernandes

name.first = nil --> Remove the key from the table.

-- To use strings:
sum = {["+"] = "add"}
print(sum["+"]) --> "add"
</code></pre><h2>Chapter 6</h0>
<h3>Functions</h0>
<pre><code class="language-lua">
function add(array)
  local sum = 0
  for i=1, #array do
    sum = sum + array[i]
  end
  return sum
end

print(add({20, 20})) --> 40
</code></pre><p>Variadic functions (variable number of arguments)</p>
<pre><code class="language-lua">
function add(...)
  local sum = 0
  for _, v in pairs({...}) do
    sum = sum + v
  end
  return sum
end

print(add(3, 4, 5, 6, 7)) --> 25
</code></pre><h3>Exercices</h0>
<p>Write a function that takes an array and prints all its elements <pre><code class="language-lua">
#!/usr/bin/luajit</p>

function print_array(array)
  print(unpack(array))
end

print(print_array({3, 4, 5, 6, 7}))
</code></pre><p>Write a function that takes an arbitrary number of values and returns all of them, with the exception of the first one.</p>
<pre><code class="language-lua">
function all_but_first(first, ...)
  return ...
end

print(all_but_first(1, 2, 10)) --> 2 10
print(all_but_first(1, "5", "word")) --> "5" "word"
</code></pre><p>Write a function that takes an arbitrary number of values and returns all of them, with the exception of the last one.</p>
<pre><code class="language-lua">
#!/usr/bin/luajit

function all_but_last(...)
  array = {...}
  table.remove(array)
  return unpack(array)
end

print(all_but_last(1, 2, 10)) --> 1 2
print(all_but_last(1, "5", "word")) --> 1 "5"
</code></pre><h2>Chapter 18</h0>
<h3>Generic for</h0>
<pre><code class="language-lua">
-- given a function to iterate
-- over an array using closures
function array_iterator(array)
  local i = 0
  return function()
    i = i + 1
    return array[i]
  end
end

-- you can use a while loop
array = {10, 20, 30}
iterator = array_iterator(array)
while true do
  element = iterator()
  if element == nil then
    break
  print(element)
  end
end

-- But you could use the generic for
for element in array_iterator(array) do
  print(element)
end
</code></pre><p>Stateless iterators:</p>
<pre><code class="language-lua">
#!/usr/bin/luajit

local function array_iterator(array, index)
  index = index + 1
  local value = array[index]
  if value then
    return index, value
  end
end

local function stateless_array_iterator(array)
  return array_iterator, array, 0
end

array = {10, 20, 30}

for index, element in stateless_array_iterator(array) do
  print(index, element)
end
</code></pre><h2>Chapter 20</h0>
<h3>Metatables and metamethods</h0>
<pre><code class="language-lua">
-- setting and getting metatables
table = {}
second_table = {}

setmetatable(second_table, table)
print(getmetatable(second_table) == table) --> true

-- a table can be its own metatable

setmetatable(table, table)
print(getmetatable(table) == table) --> true
</code></pre><h2>Chapter 21</h0>
<h3>Object<ul><li>OOrriieenntteedd  PPrrooggrraammmmiinngg</h0>
 Whenever a <code>:</code> is present on a function name, Lua injects a <code>self</code> keyword in the body of the function:</li></ul>
<pre><code class="language-lua">
Account = {balance=0}
function Account:withdraw(amount)
  self.balance = self.balance - amount
end

acc = Account
acc:withdraw(10)
print(acc.balance) --> -10

-- the above is only syntax sugar.
-- you can achieve the same as:
Account = {balance=0}
function Account.withdraw(self, amount)
  self.balance = self.balance - amount
end

acc = Account
-- pass the extra argument here.
acc.withdraw(acc, 10)
print(acc.balance) --> -10
</code></pre><p>Creating classes</p>
<pre><code class="language-lua">
-- Lua uses the idea of prototypes like
-- JavaScript. To set the prototype of
-- an object, do this:
setmetatable(A, {__index = B})
-- now A looks up to B for
-- all operations that it does
-- not have.
</code></pre><p>Thus we can create account objects:</p>
<pre><code class="language-lua">
-- defaults
Account = {balance=0}

-- methods
function Account:withdraw(amount)
  self.balance = self.balance - amount
end

-- constructors
local mt = {__index = Account}
function Account.new(o)
  o = o or {}
  setmetatable(o, mt)
  return o
end

acc = Account.new()
acc:withdraw(50)
print(acc.balance) --> -50
</code></pre><p>You can improve this by setting the prototype in the constructor directly</p>
<pre><code class="language-lua">
-- defaults
Account = {balance=0}

-- constructors
function Account:new(o)
  o = o or {}
  -- use the Account table
  -- as the instance prototype
  self.__index = self
  setmetatable(o, self)
  return o
end

-- methods
function Account:withdraw(amount)
  self.balance = self.balance - amount
end


acc = Account:new()
acc:withdraw(70)
print(acc.balance) --> -70
</code></pre><p>Inheritance:</p>
<pre><code class="language-lua">
#!/usr/bin/luajit

-- defaults
Account = {balance=0}

-- constructors
function Account:new(o)
  o = o or {}
  -- use the Account table
  -- as the instance prototype
  self.__index = self
  setmetatable(o, self)
  return o
end

-- methods
function Account:withdraw(amount)
  if amount > self.balance then
    error("insufficient funds")
  end
  self.balance = self.balance - amount
end

-- The SpecialAccount allows users
-- to withdraw more than they own

-- defaults
-- SpecialAccount = an account object with
-- the Account prototype.
SpecialAccount = Account:new()

-- methods
-- override withdraw
function SpecialAccount:withdraw(amount)
  if (amount - self.balance) >= self:get_limit() then
    error("insufficient funds")
  end
  self.balance = self.balance - amount
end

function SpecialAccount:get_limit()
  return self.limit or 0
end

special_acc = SpecialAccount:new({limit=1000})
special_acc:withdraw(999)
print(special_acc.balance) --> -999

-- this line returns an error
special_acc:withdraw(1000)
</code></pre>