<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
      text-align: justify;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 5px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>2024-06-8</p>
<h1><code>mov edi, edi</code></h1>
<p>I had a surprise today when I saw the instruction <code>mov edi, edi</code> as the first
instruction of a function call.</p>
<p>This is my C code:</p>
<pre><code class="language-c">unsigned int func(unsigned int idx) {
  static unsigned int my_table[] = {10, 20, 30, 40};
  return my_table[idx];
}
</code></pre>
<p>Which returned the following x86 assembly (compiled via gcc):</p>
<pre><code class="language-asm">func:
  mov  edi, edi
  lea  rax, my_table.0[rip]
  mov  eax, DWORD PTR [rax+rdi*4]
  ret
  .size  func, .-func
  .section  .rodata
  .align 16
  .type  my_table.0, @object
  .size  my_table.0, 16
my_table.0:
  .long  10
  .long  20
  .long  30
  .long  40
</code></pre>
<p>This code was compiled with the flag <code>-O3</code>, which I thought was going to
eliminate all useless instructions. To my surprise, when I removed all the
<code>unsigned</code> keywords from the function, the <code>mov edi, edi</code> disappeared! Here's
the equivalent asm code:</p>
<pre><code class="language-asm">func:
  movsx  rdi, edi
  lea  rax, my_table.0[rip]
  mov  eax, DWORD PTR [rax+rdi*4]
  ret
  .size  func, .-func
  .section  .rodata
  .align 16
  .type  my_table.0, @object
  .size  my_table.0, 16
my_table.0:
  .long  10
  .long  20
  .long  30
  .long  40
</code></pre>
<p>I went on a spiral of research, and I found many links pointing to this
instruction being necessary in Microsoft Windows, so that the OS could operate
hot-patching. <a href="https://devblogs.microsoft.com/oldnewthing/20110921-00/?p=9583">source</a></p>
<p>However, I compiled this on Linux. This should not be relevant to me. Here is
the catch; that operation is used for zero'ing the most significant 32 bits of
the register.</p>
<p>It does not seem obvious, but the answer can be found in the x86 tour of Intel
manuals <a href="http://web.archive.org/web/20240415061928/http://x86asm.net/articles/x86-64-tour-of-intel-manuals/">source</a></p>
<blockquote>
<p><strong>General-purpose Registers</strong>
(...)</p>
<ul>
<li>32-bit operands generate a 32-bit result, zero-extended to a 64-bit result
in the destination general-purpose register.
(...)</li>
</ul>
</blockquote>
<p>And that is indeed what happens when I try to run the following mock assembly
code below:</p>
<pre><code class="language-asm">main:
  ; Load `rdi` with all one's.
  mov rdi, 0xFFFFFFFFFFFFFFFF
  ; After the instruction below,
  ; rdi will be 0x0000000011111111
  mov edi, edi
  ret
</code></pre>
<p>This was not obvious to me at all. The initial instruction <code>mov edi, edi</code> just
looked like a nop equivalent with two bytes...</p>
<p>Coming back to my original function:</p>
<pre><code class="language-c">unsigned int func(unsigned int idx) {
  static unsigned int my_table[] = {10, 20, 30, 40};
  return my_table[idx];
}
</code></pre>
<p>Since I am using unsigned integers, the compiler can trust that the arguments
passed to that function in assembly won't be more than 32 bits long in my
machine.</p>
<p>Remember that the ABI for C functions calls in assembly is that the first
argument to the function, in this case <code>idx</code>, will be passed in the register
<code>rdi</code>.</p>
<p>So this function is cleaning up the most significant bits of <code>rdi</code> for us. I am
still not totally sure why this is necessary, but perhaps the compiler assumes
that some garbage could be held in the most significant bits of <code>rdi</code> and tries
to clean that up first to avoid potential bugs.</p>
<p>This assumption makes sense to me at first, because down in the assembly
function body, we rely on <code>rdi</code> for finding the address offset of the element
in the table that we want to return: <code>mov  eax, DWORD PTR [rax+rdi*4]</code>.</p>
<p>Now remains the question: &quot;Why is there an assumption by the compiler that
<code>rdi</code> can contain garbage in the most significant bits?&quot;.</p>
<p>This can happen if the function is being called with a &quot;casted&quot; value given
that casting per-se does not clean up unused bits of a 64bit register.</p>
<p>Again, this is very much based on my own understanding on how assembly works in
my platform, if you think that I got something wrong please send me an email at
<code>marceelofernandes@gmail.com</code>.</p>
</body>
</html>
