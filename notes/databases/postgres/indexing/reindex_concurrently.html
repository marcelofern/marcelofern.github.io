<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 10px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1>REINDEX CONCURRENTLY</h1>
<pre><code class="language-">Created at: 2024-12-20
</code></pre><p>Reindexing is a good strategy to address <a href="notes/databases/postgres/performance/table_bloat.html">index bloat</a>.</p>
<p>This operation will create a fresh new index from scratch.</p>
<h2>Sandbox</h2>
<p>In shell 1:</p>
<pre><code class="language-sql">CREATE DATABASE reindex_concurrently;

DROP TABLE IF EXISTS foo;
CREATE TABLE foo (id SERIAL PRIMARY KEY, bar INTEGER);
CREATE INDEX bar_idx ON foo (bar);

INSERT INTO foo (bar) SELECT generate_series(1, 10000);
</code></pre><p>In shell 2:</p>
<pre><code class="language-sql">INSERT INTO foo (bar) VALUES (1);
</code></pre><p>Back in Shell 1:</p>
<pre><code class="language-sql">REINDEX INDEX CONCURRENTLY bar_idx;
</code></pre><p>This will hang because shell 2 has an open transaction. If you cancel the REINDEX operation, you will see the following index:</p>
<pre><code class="language-">                            Table "public.foo"
 Column |  Type   | Collation | Nullable |             Default
--------+---------+-----------+----------+---------------------------------
 id     | integer |           | not null | nextval('foo_id_seq'::regclass)
 bar    | integer |           |          |
Indexes:
    "foo_pkey" PRIMARY KEY, btree (id)
    "bar_idx" btree (bar)
    "bar_idx_ccnew" btree (bar) INVALID
</code></pre><p>The more concurrent reindexes fail, the more <code>ccnew</code> indexes will show up:</p>
<pre><code class="language-">    "bar_idx_ccnew" btree (bar) INVALID
    "bar_idx_ccnew1" btree (bar) INVALID
    "bar_idx_ccnew2" btree (bar) INVALID
    "bar_idx_ccnew3" btree (bar) INVALID
</code></pre><p>Postgres internally calls the function <code>ReindexRelationConcurrently</code> that has this following explanation:</p>
<pre><code class="language-"> * ReindexRelationConcurrently - process REINDEX CONCURRENTLY for given
 * relation OID
 *
 * 'relationOid' can either belong to an index, a table or a materialized
 * view.  For tables and materialized views, all its indexes will be rebuilt,
 * excluding invalid indexes and any indexes used in exclusion constraints,
 * but including its associated toast table indexes.  For indexes, the index
 * itself will be rebuilt.
</code></pre><p>The index creation and replacement happens in 6 steps (comment extracted from the code after all the indexes for the operation are found).</p>
<pre><code class="language-">	/*-----
	 * Now we have all the indexes we want to process in indexIds.
	 *
	 * The phases now are:
	 *
	 * 1. create new indexes in the catalog
	 * 2. build new indexes
	 * 3. let new indexes catch up with tuples inserted in the meantime
	 * 4. swap index names
	 * 5. mark old indexes as dead
	 * 6. drop old indexes
	 *
	 * We process each phase for all indexes before moving to the next phase,
	 * for efficiency.
	 */

	/*
	 * Phase 1 of REINDEX CONCURRENTLY
	 *
	 * Create a new index with the same properties as the old one, but it is
	 * only registered in catalogs and will be built later.  Then get session
	 * locks on all involved tables.  See analogous code in DefineIndex() for
	 * more detailed comments.
	 */
</code></pre><p>Now on shell 2:</p>
<pre><code class="language-sql">ROLLBACK;
</code></pre><p>And back on shell 1, finally reindex again:</p>
<pre><code class="language-sql">REINDEX INDEX CONCURRENTLY bar_idx;
</code></pre><p><b>Important</b>: None of the <code>ccnew</code> indexes will be removed, you have to do that manually!</p>
<script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>
</html>
