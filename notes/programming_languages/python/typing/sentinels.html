<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 10px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>February 22, 2024</p>
<h2>Support Reading</h0>
<p><a href="https://web.archive.org/web/20231222001234/https://peps.python.org/pep-0661/">pep-0661</a></p>
<h2>Definition</h0>
<p>If you have a dictionary in Python and you perform:</p>
<pre><code class="language-python">
my_dict.get("my_key")
</code></pre><p>You will get <code>None</code> if either the <code>my_key</code> doesn't exist, or if it exists and the value of that key is <code>None</code>.</p>
<p>This is cause for ambiguity because <code>None</code> means two things at the same time.</p>
<p>Function arguments can suffer from the same problem:</p>
<pre><code class="language-python">
def is_it_bed_time(hour_to_go_to_bed: int | None = None) -> bool:
    if hour_to_go_to_bed is None:
        print("I don't have a time to go to bed mom!")
    if datetime.now().hour > hour_to_go_to_bed:
        print("Go to sleep!")
    else:
        print("Don't go to sleep yet!)
</code></pre><p>What happens if you want <code>None</code> to be a possible value, but also you'd like to have a default if the caller didn't pass in the argument?</p>
<p>This is what sentinels are for.</p>
<pre><code class="language-python">
class NotProvided:
    pass

DEFAULT_HOUR = 23

def is_it_bed_time(
    hour_to_go_to_bed: int | None | NotProvided = NotProvided
) -> bool:
    # We have a default when the value is not passed.
    if hour_to_go_to_bed is NotProvided:
        hour_to_go_to_bed = DEFAULT_HOUR
    # But `None` means something different:
    elif hour_to_go_to_bed is None:
        print("I don't have a time to go to bed mom!")
        return False

    if datetime.now().hour > hour_to_go_to_bed:
        print("Go to sleep!")
        return True
    else:
        print("Don't go to sleep yet!")
        return False
</code></pre><h2>Initial problem</h0>
<p>The version above is rather simple, but it does not work well with mypy.</p>
<p>Suppose you have this:</p>
<pre><code class="language-python">
class NotProvided:
    """
    A sentinel for when an argument to a function is not provided.
    """
    pass


def foo(bar: int | None | NotProvided = NotProvided) -> int:
    if bar is NotProvided:
        bar = 0
    elif bar is None:
        bar = 42

    reveal_type(bar)

    return bar + 10
</code></pre><p>When running mypy, we get the following errors:</p>
<pre><code class="language-">
!mypy /tmp/test_type.py

/tmp/test_type.py:11: note: Revealed type is "Union[builtins.int, Type[test_type.NotProvided]]"
/tmp/test_type.py:13: error: Unsupported operand types for + ("Type[NotProvided]" and "int")  [operator]
/tmp/test_type.py:13: note: Left operand is of type "Union[int, Type[NotProvided]]"
Found 1 error in 1 file (checked 1 source file)
</code></pre><p>Even though you know that when we hit the return bar is an integer, the type narrowing cannot infer that.</p>
<p>These are some ways to narrow a type according to mypy, and <code>is</code> doesn't get a reference:</p>
<ul><li><code>isinstance()</code> like in <code>isinstance(obj, float)</code> will narrow obj to have float type</li><li><code>issubclass()</code> like in <code>issubclass(cls, MyClass)</code> will narrow cls to be<code>Type[MyClass]</code> .</li><li><code>type</code> like in <code>type(obj)</code> is int will narrow obj to have int type</li><li><code>callable()</code> like in <code>callable(obj)</code> will narrow object to callable type</li><li><code>obj is not None</code> will narrow object to its non</li><li>optional form</li></ul>
<p><a href="https://mypy.readthedocs.io/en/stable/type_narrowing.html">Source</a></p>
<h2>Overcoming the typing limitation</h0>
<p>The list above says that <code>isinstance</code> would type narrow the sentinel value.</p>
<pre><code class="language-python">
class NotProvidedType(type):
    pass

class NotProvided(metaclass=NotProvidedType):
    pass


def foo(bar: int | None | NotProvidedType = NotProvided) -> int:
    if isinstance(bar, NotProvidedType):
        bar = 0
    elif bar is None:
        bar = 42

    reveal_type(bar)

    return bar + 10
</code></pre><pre><code class="language-">
/tmp/test_type.py:14: note: Revealed type is "builtins.int"
</code></pre><p>This works, but having to resort to <code>isinstance</code> isn't always the best.</p>
<h2>Using a singleton type</h0>
<p>A colleague at work investigated this issue and came up with a clever idea:</p>
<pre><code class="language-python">
import typing
import enum

@enum.unique
class Sentinel(enum.Enum):
    NotProvided = enum.auto()

    def __repr__(self) -> str:
        return self.name

    def __str__(self) -> str:
        return self.__repr__()


NotProvidedType = typing.Literal[Sentinel.NotProvided]
NotProvided: typing.Final = Sentinel.NotProvided


def foo(bar: int | None | NotProvidedType = NotProvided) -> int:
    if bar is NotProvided:
        bar = 0
    elif bar is None:
        bar = 42

    reveal_type(bar)

    return bar + 10
</code></pre><pre><code class="language-">
!mypy %
/tmp/test_type.py:25: note: Revealed type is "builtins.int"
</code></pre><h3>Breaking it down</h0>
<h4><code>@@eennuumm..uunniiqquuee`</code></h0>
<p>Ensures the enumeration only has unique member values. If you have more sentinels this is just generally good to have</p>
<pre><code class="language-python">
import enum

@enum.unique
class Sentinel(enum.Enum):
    value_1 = "test"
    value_2 = "test"
</code></pre><pre><code class="language-">
:!python %
Traceback (most recent call last):
  File "/tmp/kaoekoea.py", line 4, in <module>
    class Sentinel(enum.Enum):
  File "/home/x/.pyenv/versions/3.10.6/lib/python3.10/enum.py", line 1022, in unique
    raise ValueError('duplicate values found in %r: %s' %
ValueError: duplicate values found in <enum 'Sentinel'>: value_2 -> value_1
</code></pre><h4><code>eennuumm..aauuttoo(())`</code></h0>
<p>Gives a nice initial value for the fields:</p>
<pre><code class="language-python">
import enum

@enum.unique
class Sentinel(enum.Enum):
    value_1 = enum.auto()
    value_2 = "test"
    value_3 = enum.auto()

import ipdb; ipdb.set_trace(); from pprint import pprint as p
</code></pre><pre><code class="language-">
ipdb> Sentinel.value_1
<Sentinel.value_1: 1>
ipdb> Sentinel.value_2
<Sentinel.value_2: 'test'>
ipdb> Sentinel.value_3
<Sentinel.value_3: 2>
</code></pre><h4><code>ttyyppiinngg..LLiitteerraall`</code></h0>
<pre><code class="language-">
NotProvidedType = typing.Literal[Sentinel.NotProvided]
</code></pre><p>This form can be used to indicate to type checkers that the corresponding variable or function parameter has a value equivalent to the provided literal (or one of several literals):</p>
<pre><code class="language-python">
def validate_simple(data: Any) -> Literal[True]:  # always returns True
  ...

MODE = Literal['r', 'rb', 'w', 'wb']
def open_helper(file: str, mode: MODE) -> str:
</code></pre><h4><code>ttyyppiinngg..FFiinnaall`</code></h0>
<pre><code class="language-">
NotProvided: typing.Final = Sentinel.NotProvided
</code></pre><p>Special typing construct to indicate final names to type checkers. A final name cannot be re-assigned or overridden in a subclass. For example:</p>
<pre><code class="language-python">
MAX_SIZE: Final = 9000
MAX_SIZE += 1  # Error reported by type checker

class Connection:
  TIMEOUT: Final[int] = 10

class FastConnector(Connection):
  TIMEOUT = 1  # Error reported by type checker
</code></pre>