<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 10px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1>Should you not use Postgres varchar(n) by default?</h0>
<pre><code class="language-">
Created at: 2025-02-01
</code></pre><p>The Postgres wiki has a page called <a href="https://wiki.postgresql.org/wiki/Don't_Do_This#Don.27t_use_varchar.28n.29_by_default">"Don't Do This"</a> where general good practices are discussed.</p>
<p>Amongst them, there is a session titled: <b>"Don't use varchar(n) by default"</b> which is copied verbatim below:</p>
<blockquote>**Why not?**</blockquote>
<blockquote>varchar(n) is a variable width text field that will throw an error if you try</blockquote>
<blockquote>and insert a string longer than n characters (not bytes) into it.</blockquote>
<blockquote></blockquote>
<blockquote>varchar (without the (n)) or text are similar, but without the length limit.</blockquote>
<blockquote>If you insert the same string into the three field types they will take up</blockquote>
<blockquote>exactly the same amount of space, and you won't be able to measure any</blockquote>
<blockquote>difference in performance.</blockquote>
<blockquote></blockquote>
<blockquote>If what you really need is a text field with an length limit then varchar(n)</blockquote>
<blockquote>is great, but if you pick an arbitrary length and choose varchar(20) for a</blockquote>
<blockquote>surname field you're risking production errors in the future when Hubert</blockquote>
<blockquote>Blaine Wolfe­schlegel­stein­hausen­berger­dorff signs up for service.</blockquote>
<blockquote></blockquote>
<blockquote>Some databases don't have a type that can hold arbitrary long text, or if</blockquote>
<blockquote>they do it's not as convenient or efficient or well-supported as varchar(n).</blockquote>
<blockquote>Users from those databases will often use something like varchar(255) when</blockquote>
<blockquote>what they really want is text.</blockquote>
<blockquote></blockquote>
<blockquote>If you need to constrain the value in a field you probably need something</blockquote>
<blockquote>more specific than a maximum length - maybe a minimum length too, or a</blockquote>
<blockquote>limited set of characters - and a check constraint can do all of those things</blockquote>
<blockquote>as well as a maximum string length.</blockquote>
<blockquote>**When should you?**</blockquote>
<blockquote>When you want to, really. If what you want is a text field that will throw an</blockquote>
<blockquote>error if you insert too long a string into it, and you don't want to use an</blockquote>
<blockquote>explicit check constraint then varchar(n) is a perfectly good type. Just</blockquote>
<blockquote>don't use it automatically without thinking about it.</blockquote>
<blockquote>Also, the varchar type is in the SQL standard, unlike the text type, so it</blockquote>
<blockquote>might be the best choice for writing super-portable applications.</blockquote>
<p>The reasons for using <code>varchar</code> (without the (n)) are compelling:</p>
<ol><li>No performance penalties.</li><li>Reduced risk of errors if you misrepresented the size of the data.</li></ol>
<p>What the wiki doesn't do a good job of, is steelmanning the downsides of the approach it directs towards, namely: <b>using varchar by default</b>.</p>
<p>Let's go over them.</p>
<h2>Denial<ul><li>ooff-</li><li>SSeerrvviiccee  ((DDooSS))  vviiaa  UUnnccoonnttrroolllleedd  DDaattaa  IInnsseerrttiioonn</h0>
 If you choose a bare <code>varchar</code> for your surname field, you'll need validation somewhere in the application to ensure this field doesn't become a vector for attacks.</li></ul>
<p>If a malicious party finds this free-text field without an upper-limit validation, they can perform database stuffing by storing enormous volume of data in the database, ending on a DoS attack.</p>
<p>Even if the application pre-validates the data before storing it, this level of validation is much weaker as a guarantee of data integrity than delegating the job to the database. The database is excellent for data integrity guarantees, application code is not.</p>
<p>Most services have hard constraints on such inputs. For example, the below is the limit for names on Twitter:</p>
<p><img alt="img_twitter_limits.png" src="img_twitter_limits.png"></p>
<h2>Storing free<ul><li>tteexxtt  iinn  aa  ddaattaabbaassee  mmaayy  nnoott  bbee  aa  ggoooodd  iiddeeaa</h0>
 Databases are optimised for structured data. There are better alternatives for storing free</li><li>text like S3, CDNs, or even just a dump static file server.</li></ul>
<p>Having large free-text fields stored on a table will reduce the performance of the server, at the minimum you have the overhead of a TOAST table for some large rows, but also you are slowing down many db maintenance activities and backup tasks for data that you might not always need to have at hand.</p>
<h2>Increasing the size of a varchar(n) is not a problem</h0>
<p>Performing an ALTER TABLE to pump the value of <code>n</code> up is a catalogue-only operation and won't culminate in a database outage.</p>
<p>Of course, at that point you might have had a few angry customers complaining about errors in the application. You have to ponderate if this is worth over the risks of having a DoS via Uncontrolled Data Insertion attack instead.</p>
<p>There is a real problem though if you want to <b>decrease</b> the value of <code>n</code>. This will rewrite the table:</p>
<pre><code class="language-sql">
-- This will tell you if a table is being re-written.
SET client_min_messages=debug1;

DROP TABLE IF EXISTS test;

CREATE TABLE test (id SERIAL PRIMARY KEY, str varchar(6));

INSERT INTO test (str) SELECT generate_series(1, 1000);

-- Increasing the value of `n`, no problem here.
ALTER TABLE test ALTER COLUMN str TYPE varchar(7);

-- Also completely removing `n`, no problem!
-- Caveat: this will trigger a potential "building_index" operation for the
-- TOAST table.
ALTER TABLE test ALTER COLUMN str TYPE varchar;

-- Decreasing the value of `n`. This is a risky operation!
ALTER TABLE test ALTER COLUMN str TYPE varchar(4);
-- DEBUG:  rewriting table "test"
</code></pre><p>I haven't seen cases of having to reduce the value of <code>n</code> before in production.</p>
<p>But even then, there is a way to set a lower upper bound without downtime via check constraints:</p>
<pre><code class="language-sql">
-- [OPTIONAL] you can promote the field to a bare varchar first
ALTER TABLE test ALTER COLUMN str TYPE varchar;

-- Add a NOT VALID constraint, so that it does not scan the table while holding
-- an AccessExclusive Lock.
ALTER TABLE test
ADD CONSTRAINT chk_str_length CHECK (LENGTH(str) <= 4)
NOT VALID;

-- This will only acquire a ShareUpdateExclusiveLock
ALTER TABLE test VALIDATE CONSTRAINT chk_str_length;
</code></pre><p>Note that the check constraint performance may be slower than the native <code>varchar(n)</code> check due to the function evaluations behind performing a constraint check.</p>
<h2>Conclusions</h0>
<ul><li>Think thoroughly about upper/lower bounds of your data before creating a field.</li><li>Ponderate between the risks of having length</li><li>limit errors versus a potential DDoS attack surface.</li><li><b>Do not</b> reach out for free</li><li>text fields by default. Unless you are always adding a CHECK CONSTRAINT to sanitise input limits.</li></ul>