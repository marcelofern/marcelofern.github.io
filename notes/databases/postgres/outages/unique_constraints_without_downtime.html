<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 10px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1>UNIQUE Constraints Without Downtime</h1>
<pre><code class="language-">Created at: 2025-01-13
</code></pre><p>The following DDL is used to add a unique constraint on an existing table:</p>
<pre><code class="language-sql">ALTER TABLE table ADD CONSTRAINT constraint UNIQUE (field);
</code></pre><p>Which has the following problems:</p>
<ul><li>It acquires an ACCESS EXCLUSIVE lock on the table that blocks reads and writes on the table. This can take a long time as the index that backs up the constraint is being built.</li><li>In turn, it can also be blocked by a existing query. For example, a long-running transaction could block this query, which in turn will block other queries, creating a potential outage.</li><li>It doesn't work with retries, as it doesn't check if the constraint already exists before attempting the ALTER TABLE.</li></ul>
<p>Note: In Postgres, unique constraints are implemented as unique indexes. Unique indexes already give the same constrictions as unique constraints.</p>
<h2>A safer approach</h2>
<p>We use a UNIQUE index to build the constraint. This UNIQUE index can be created without taking AccessExclusive locks via CREATE UNIQUE INDEX CONCURRENTLY.</p>
<pre><code class="language-sql">-- Necessary to avoid lock timeouts. This is a safe operation as
-- CREATE UNIQUE INDEX CONCURRENTLY takes a weaker SHARE UPDATE EXCLUSIVE
-- lock.
SET lock_timeout = 0;

-- Check if an INVALID index already exists.
SELECT relname
FROM pg_class, pg_index
WHERE (
    pg_index.indisvalid = false
    AND pg_index.indexrelid = pg_class.oid
    AND relname = 'foo_unique_idx'
);

-- Remove the invalid index (only if the previous query returned one).
DROP INDEX CONCURRENTLY IF EXISTS foo_unique_idx;

-- Finally create the UNIQUE index
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS foo_unique_idx ON table;

-- Reset lock_timeout to its original value ("1s" as an example).
SET lock_timeout = '1s';

-- Perform the ALTER TABLE using the unique index just created.
-- This will run very fast as the index is enough proof that there aren't
-- violations in the table.
ALTER TABLE "table"
ADD CONSTRAINT "foo_unique"
UNIQUE USING INDEX "foo_unique_idx";
</code></pre><h2>USING syntax</h2>
<pre><code class="language-">ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ]
    action [, ... ]

Where action is:

    ADD table_constraint_using_index

Where table_constraint_using_index is:

    [ CONSTRAINT constraint_name ]
    { UNIQUE | PRIMARY KEY } USING INDEX index_name
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</code></pre><p>By default, constraints are set as DEFERRABLE INITIALLY IMMEDIATE unless specified.</p>
<p>Deferrability cheat-sheet:</p>
<ul><li><code>DEFERRABLE</code>: the default deferrability can be changed in a transaction.</li><li><code>NOT DEFERRABLE</code> : the default deferrability <b>cannot</b> be changed in a transaction. Plus, will always be IMMEDIATE. Trying to set it otherwise will result in error: ERROR:  constraint declared INITIALLY DEFERRED must be DEFERRABLE LINE 4: NOT DEFERRABLE INITIALLY DEFERRED;</li><li><code>INITIALLY DEFERRED</code> : by default, wait until the end of the transaction to check the constraint.</li><li><code>INITIALLY IMMEDIATE</code> : by default, check the constraint immediately, that is, without waiting until the end of the transaction.</li></ul>
<blockquote>Upon creation, a constraint is given one of three characteristics: DEFERRABLE</blockquote>
<blockquote>INITIALLY DEFERRED, DEFERRABLE INITIALLY IMMEDIATE, or NOT DEFERRABLE. The</blockquote>
<blockquote>third class is always IMMEDIATE and is not affected by the SET CONSTRAINTS</blockquote>
<blockquote>command. The first two classes start every transaction in the indicated mode,</blockquote>
<blockquote>but their behavior can be changed within a transaction by SET CONSTRAINTS.</blockquote>
<h2>Sandbox Example</h2>
<pre><code class="language-sql">DROP TABLE IF EXISTS foo;
CREATE TABLE foo (
  id SERIAL PRIMARY KEY,
  int_val INTEGER NOT NULL
);

INSERT INTO foo (int_val) SELECT generate_series(1, 10000);
SELECT count(*) FROM foo;

SET lock_timeout = 0;

DROP INDEX CONCURRENTLY IF EXISTS foo_unique_idx;
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS foo_unique_idx ON foo (int_val);

ALTER TABLE foo
ADD CONSTRAINT foo_unique
UNIQUE USING INDEX foo_unique_idx;
</code></pre><pre><code class="language-">                             Table "public.foo"
 Column  |  Type   | Collation | Nullable |             Default
---------+---------+-----------+----------+---------------------------------
 id      | integer |           | not null | nextval('foo_id_seq'::regclass)
 int_val | integer |           | not null |
Indexes:
    "foo_pkey" PRIMARY KEY, btree (id)
    "foo_unique" UNIQUE CONSTRAINT, btree (int_val)
</code></pre><script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>
</html>
