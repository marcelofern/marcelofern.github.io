<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 10px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1>Schema Basics</h1>
<pre><code class="language-">Created at: 2025-05-05
</code></pre><h2>Creation And Deletion</h2>
<pre><code class="language-sql">CREATE SCHEMA myschema;
-- With authorisation for a user
CREATE SCHEMA schema_name AUTHORIZATION user_name;

-- Might have to use CASCADE if the schema isn't empty
DROP SCHEMA myschema;
DROP SCHEMA myschema CASCADE;
</code></pre><h2>Search Path</h2>
<blockquote>Qualified names are tedious to write, and it's often best not to wire a</blockquote>
<blockquote>particular schema name into applications anyway. Therefore tables are often</blockquote>
<blockquote>referred to by unqualified names, which consist of just the table name. The</blockquote>
<blockquote>system determines which table is meant by following a search path, which is a</blockquote>
<blockquote>list of schemas to look in. The first matching table in the search path is</blockquote>
<blockquote>taken to be the one wanted. If there is no match in the search path, an error</blockquote>
<blockquote>is reported, even if matching table names exist in other schemas in the</blockquote>
<blockquote>database.</blockquote>
<pre><code class="language-sql">SHOW search_path;
--  search_path
-- --------------
--  "$user", public


-- Allow querying tables without the `myschema.` prefix.
-- Warning, paths are selected in order, so if both myschema and public have a
-- table of the same name, myschema will return its table when selecting
-- without the schema prefix.
SET search_path TO myschema, public;
</code></pre><h2>Sequences Are Schema Aware</h2>
<pre><code class="language-sql">CREATE SCHEMA IF NOT EXISTS schema1;
CREATE SCHEMA IF NOT EXISTS schema2;

-- Create sequences with the same name in different schemas
CREATE SEQUENCE schema1.my_sequence;
CREATE SEQUENCE schema2.my_sequence;

-- Test that both sequences can exist and be used independently
SELECT nextval('schema1.my_sequence') AS schema1_seq;
SELECT nextval('schema2.my_sequence') AS schema2_seq;
</code></pre><h2>Functions Are Schema Aware</h2>
<pre><code class="language-sql">-- Create schemas
CREATE SCHEMA IF NOT EXISTS schema1;
CREATE SCHEMA IF NOT EXISTS schema2;

-- Create functions with the same name in different schemas
CREATE FUNCTION schema1.my_function() RETURNS text AS $$
BEGIN
    RETURN 'Function from schema1';
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION schema2.my_function() RETURNS text AS $$
BEGIN
    RETURN 'Function from schema2';
END;
$$ LANGUAGE plpgsql;

-- Test calling both functions
SELECT schema1.my_function() AS result_schema1;
SELECT schema2.my_function() AS result_schema2;
</code></pre><h2>Indexes Are Schema Aware</h2>
<pre><code class="language-sql">-- Create schemas
CREATE SCHEMA IF NOT EXISTS schema1;
CREATE SCHEMA IF NOT EXISTS schema2;

-- Create tables with the same name in different schemas
DROP TABLE IF EXISTS schema1.my_table CASCADE;
CREATE TABLE schema1.my_table (id serial PRIMARY KEY, name text);

DROP TABLE IF EXISTS schema2.my_table CASCADE;
CREATE TABLE schema2.my_table (id serial PRIMARY KEY, name text);

-- Create indexes on both tables
CREATE INDEX same_name_idx ON schema1.my_table(name);
CREATE INDEX same_name_idx ON schema2.my_table(name);

-- Test the existence of indexes
SELECT * FROM pg_indexes WHERE tablename = 'my_table' AND schemaname = 'schema1';
SELECT * FROM pg_indexes WHERE tablename = 'my_table' AND schemaname = 'schema2';
</code></pre><h2>A table from one schema can ref a table from another</h2>
<pre><code class="language-sql">-- Create two schemas
CREATE SCHEMA IF NOT EXISTS schema1;
CREATE SCHEMA IF NOT EXISTS schema2;

-- In schema1, create a referenced table
DROP TABLE IF EXISTS schema1.users CASCADE;
CREATE TABLE schema1.users (
    id SERIAL PRIMARY KEY,
    username TEXT NOT NULL
);
DO $$
BEGIN
    FOR i IN 1..100 LOOP
        INSERT INTO schema1.users (username)
        VALUES ('user_' || i);
    END LOOP;
END $$;

-- In schema2, create a table that references schema1.users
DROP TABLE IF EXISTS schema2.orders CASCADE;
CREATE TABLE schema2.orders (
    id SERIAL PRIMARY KEY,
    user_id INT,
    FOREIGN KEY (user_id) REFERENCES schema1.users(id)
);
DO $$
BEGIN
    FOR i IN 1..100 LOOP
        INSERT INTO schema2.orders (user_id)
        VALUES (FLOOR(RANDOM() * 100 + 1)::INT);
    END LOOP;
END $$;
</code></pre><script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>
</html>
