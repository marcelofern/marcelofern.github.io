<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
      text-align: justify;
    }
    /* add empty line before <pre> blocks */
    pre:before {
        content: "\A";
        white-space: pre;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 5px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>February 24th, 2024</p>
<p>Let's start with a simple C function:</p>
<pre><code class="language-c">extern int get_int();

int foo(int a) {
   int b = get_int();
   int c = get_int();
   int d = get_int();
  return a * (b + c + d);
}
</code></pre>
<p>The assembly code generated by gcc without optimisation looks like this:</p>
<pre><code class="language-asm">foo:
  push  rbp
  mov  rbp, rsp
  sub  rsp, 32
  mov  DWORD PTR -20[rbp], edi
  mov  eax, 0
  call  get_int@PLT
  mov  DWORD PTR -12[rbp], eax
  mov  eax, 0
  call  get_int@PLT
  mov  DWORD PTR -8[rbp], eax
  mov  eax, 0
  call  get_int@PLT
  mov  DWORD PTR -4[rbp], eax
  mov  edx, DWORD PTR -12[rbp]
  mov  eax, DWORD PTR -8[rbp]
  add  edx, eax
  mov  eax, DWORD PTR -4[rbp]
  add  eax, edx
  imul  eax, DWORD PTR -20[rbp]
  leave
  ret
</code></pre>
<p>We see the prologue:</p>
<pre><code class="language-asm">push rbp
mov rbp, rsp
</code></pre>
<p>This pushes to memory the value of rbp (base pointer register), and moves the
value of the stack pointer register rsp in to the base pointer.</p>
<p>This basically creates a stack frame. Now the function can use memory space for
its own variables without messing up the caller's stack frame.</p>
<h2>Body of foo</h2>
<p>In the body we have a pretty regular assembly code.</p>
<h3>Setting up memory and function arguments</h3>
<ul>
<li><code>sub rsp, 32</code>: Reserves 32 bytes of memory.</li>
<li><code>mov dword ptr [rbp-20], edi</code>: saves <code>int a</code> in rbp-20.</li>
</ul>
<h3>Setting up function variables in memory</h3>
<ul>
<li><p><code>mov eax, 0 &amp; call get_int</code>: fetches <code>int b</code> into eax.</p>
</li>
<li><p><code>mov dword ptr [rbp-12], eax</code>: saves <code>int b</code> in rbp-12.</p>
</li>
<li><p><code>mov eax, 0 &amp; call get_int</code>: fetches <code>int c</code> into eax.</p>
</li>
<li><p><code>mov dword ptr [rbp-8], eax</code>: saves <code>int c</code> in rbp-8.</p>
</li>
<li><p><code>mov eax, 0 &amp; call get_int</code>: fetches <code>int d</code> into eax.</p>
</li>
<li><p><code>mov dword ptr [rbp-4], eax</code>: saves <code>int d</code> in rbp-4.</p>
</li>
</ul>
<p>Note that the compiler knew we had 4 integers we needed to store in memory.
Integers occupy 4 bytes each, so that means <code>4 * 4</code> we needed 16 bytes of
memory to hold all integers.</p>
<p>The first 4 bytes in <code>rbp</code> store the old value of the stack pointer, so our
loading of memory starts at address rbp -4 and ends at rbp -20.</p>
<h3>Calculating the result</h3>
<ul>
<li><code>mov  edx, DWORD PTR -12[rbp]</code>: moves b into edx</li>
<li><code>mov  eax, DWORD PTR -8[rbp]</code>: moves c into eax</li>
<li><code>add  edx, eax</code>: adds b + c</li>
<li><code>mov  eax, DWORD PTR -4[rbp]</code>: moves d into eax</li>
<li><code>add  eax, edx</code>: calculates b + c + d into eax</li>
<li><code>imul  eax, DWORD PTR -20[rbp]</code>: multiplies sum by a.</li>
</ul>
<h3>Epilogue</h3>
<p>Finally we call <code>leave</code> which is the equivalent of:</p>
<pre><code class="language-asm">mov rsp, rbp
pop rbp
</code></pre>
<h2>What is the function call overhead?</h2>
<p>The overhead is pretty much creating and destroying the stack frame. Pushing
and popping things from memory isn't as fast as doing operations on registers
and memory manipulation incurs higher performance penalties.</p>
<p>Additionally, before calling a function, the caller might have to push register
values into the stack - given that the code in the function itself might change
value of certain registers (non-volatile registers).</p>
<p>Argument passing is also a problem, note how our argument <code>int a</code> was passed
in register <code>edi</code>. The caller might have to do some register manipulation to
put <code>a</code> into <code>edi</code> if that value is not there already.</p>
<h2>How to minimise function call overhead?</h2>
<p>The compiler by itself might decide to inline trivial functions. If your
function is complex and the compiler didn't inline it for you, you might decide
to do that by yourself. This is possible if your function is only called from a
single place.</p>
</body>
</html>
