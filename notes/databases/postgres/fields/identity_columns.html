<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <style rel="stylesheet">
    body{
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      margin:40px auto;
      max-width:750px;
      font-size:18px;
      padding:0 10px;
      color: #333;
    }
    pre {
      background: #f4f4f4;
      border: 1px solid #ddd;
      border-left: 3px solid #000;
      color: #777;
      page-break-inside: avoid;
      font-family: monospace;
      font-size: 15px;
      max-width: 100%;
      overflow: auto;
      padding: 1em 1.5em;
      display: block;
      word-wrap: break-word;
    }
    a {
      color: #1976d2;
      text-decoration: none;
      border-bottom: 1px solid;
    }
    img {
      max-width: 100%;
    }
    h1 {
      text-align: left;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    li {
      margin-bottom: 10px;
    }
    :not(pre) > code {
      background-color: #f4f4f4;
      padding-right: 0.2em;
      padding-left: 0.2em;
      border-radius: 3px;
    }
  </style>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1>Identity Columns</h1>
<pre><code>Created at: 2025-04-15
</code></pre>
<p>Identity columns can be created with the following statements:</p>
<pre><code class="language-sql">DROP TABLE IF EXISTS foo;
CREATE TABLE foo (
    id1 SERIAL PRIMARY KEY,
    id2 INT GENERATED ALWAYS AS IDENTITY,
    id3 BIGINT GENERATED BY DEFAULT AS IDENTITY,
    val INT NOT NULL
);
</code></pre>
<p>The identity column will be back-up (behind the scenes) by a sequence.
For example, you can find the underlying sequence in this way:</p>
<pre><code class="language-sql">SELECT
  *
FROM
  pg_sequences
WHERE
  sequencename IN (
      split_part(pg_get_serial_sequence('foo', 'id2'), '.', 2),
      split_part(pg_get_serial_sequence('foo', 'id3'), '.', 2)
  );

-- -[ RECORD 1 ]-+--------------------
-- schemaname    | public
-- sequencename  | foo_id2_seq
-- sequenceowner | username
-- data_type     | integer
-- start_value   | 1
-- min_value     | 1
-- max_value     | 2147483647
-- increment_by  | 1
-- cycle         | f
-- cache_size    | 1
-- last_value    |
-- -[ RECORD 2 ]-+--------------------
-- schemaname    | public
-- sequencename  | foo_id3_seq
-- sequenceowner | username
-- data_type     | bigint
-- start_value   | 1
-- min_value     | 1
-- max_value     | 9223372036854775807
-- increment_by  | 1
-- cycle         | f
-- cache_size    | 1
-- last_value    |
</code></pre>
<p>The sequence <code>max_value</code> and <code>data_type</code> are defined implicitly by the column
data type. That's why the bigint (id3) column has a much larger <code>max_value</code>.</p>
<h2>ALWAYS vs BY DEFAULT</h2>
<blockquote>
<p>The clauses ALWAYS and BY DEFAULT in the column definition determine how
explicitly user-specified values are handled in INSERT and UPDATE commands.
In an INSERT command, if ALWAYS is selected, a user-specified value is only
accepted if the INSERT statement specifies OVERRIDING SYSTEM VALUE. If BY
DEFAULT is selected, then the user-specified value takes precedence. Thus,
using BY DEFAULT results in a behavior more similar to default values, where
the default value can be overridden by an explicit value, whereas ALWAYS
provides some more protection against accidentally inserting an explicit
value.</p>
</blockquote>
<p>For our table, the following would work:</p>
<pre><code class="language-sql">-- All the id* columns will be populated automatically.
INSERT INTO foo (val) VALUES (1);

-- This also works, because the value id3 was defined with BY DEFAULT and can
-- therefore be overriden.
-- NOTE: this does not update the sequence to now have its last_value updated.
-- This can be dangerous if the column is a Primary Key.
INSERT INTO foo (id3, val) VALUES (42, 1);

-- This also works, and updates the sequences too
INSERT INTO foo (id2, id3, val) VALUES (DEFAULT, DEFAULT, 1);

-- This works because of the OVERRIDING SYSTEM VALUE command. But it will not
-- update the sequence last_value.
INSERT INTO foo (id2, id3, val) OVERRIDING SYSTEM VALUE VALUES (42, 64, 1);
</code></pre>
<p>The following would not work:</p>
<pre><code class="language-sql">INSERT INTO foo (id2, id3, val) VALUES (42, DEFAULT, 1);
-- ERROR:  cannot insert a non-DEFAULT value into column &quot;id2&quot;
-- DETAIL:  Column &quot;id2&quot; is an identity column defined as GENERATED ALWAYS.
-- HINT:  Use OVERRIDING SYSTEM VALUE to override.
</code></pre>
<p>This is what our table looks like after the experiments:</p>
<pre><code class="language-sql">select * from foo;
--  id1 | id2 | id3 | val
-- -----+-----+-----+-----
--    1 |   1 |   1 |   1
--    2 |   2 |  42 |   1
--    3 |   3 |   2 |   1
--    5 |  42 |  64 |   1

-- schemaname    | public
-- sequencename  | foo_id2_seq
-- sequenceowner | username
-- data_type     | integer
-- start_value   | 1
-- min_value     | 1
-- max_value     | 2147483647
-- increment_by  | 1
-- cycle         | f
-- cache_size    | 1
-- last_value    | 4
-- -[ RECORD 2 ]-+--------------------
-- schemaname    | public
-- sequencename  | foo_id3_seq
-- sequenceowner | username
-- data_type     | bigint
-- start_value   | 1
-- min_value     | 1
-- max_value     | 9223372036854775807
-- increment_by  | 1
-- cycle         | f
-- cache_size    | 1
-- last_value    | 3
</code></pre>
<p>Note that the underlying sequences can be updated just as a normal sequence.</p>
<script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>
</html>
